<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>MECASONIC Support Vidéo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: sans-serif; padding: 20px; text-align: center; margin-top: 60px; }
    .video-wrapper { display: inline-block; margin: 10px; position: relative; }
    .video-wrapper h3 { margin: 5px 0; position: relative; }
    .mic-status { position: absolute; top: 0; right: -25px; font-size: 18px; }
    video { width: 320px; height: auto; border: 1px solid #333; cursor: pointer; }
    #chat { max-width: 400px; margin: 20px auto; text-align: left; }
    #messages { border:1px solid #ccc; height: 150px; overflow-y: auto; padding: 5px; }
    #controls > * { margin: 5px; }
    button { padding: 8px 12px; }
    input[readonly], input:disabled { background: #f0f0f0; }
    #status { font-weight: bold; margin-top: 10px; }
    #chat, #screenshot { display: none; }
    #status-bar {
      background: #333;
      color: #fff;
      padding: 10px;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
      font-size: 14px;
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
    }
    .ping-good { color: lightgreen; }
    .ping-warn { color: orange; }
    .ping-bad  { color: red; }
  </style>
</head>
<body>
  <div id="status-bar">
    <div style="width: 100%; text-align: center;">
      <div id="connection-status">⏳ En attente de connexion...</div>
      <div>
        <span id="latency">Ping : ...</span> |
        <span id="remote-mic-status">Micro distant : inconnu</span>
      </div>
    </div>
  </div>

  <h1>Mecasonic Support Vidéo</h1>

  <div id="videos">
    <div class="video-wrapper">
      <h3 id="local-label">... <span id="local-mic" class="mic-status">🎤</span></h3>
      <video id="local-video" autoplay muted playsinline></video>
      <button id="fullscreen-local">Plein écran</button>
    </div>
    <div class="video-wrapper">
      <h3 id="remote-label">... <span id="remote-mic" class="mic-status">🎤</span></h3>
      <video id="remote-video" autoplay playsinline></video>
      <button id="fullscreen-remote">Plein écran</button>
    </div>
  </div>

  <div id="controls">
    <button id="rotate-camera">↺ Inverser caméra</button>
    <button id="share-screen">🔍 Partager écran</button>
    <button id="toggle-audio">🔇 Couper micro</button>
    <br>
    <button id="join-btn" style="display:none;">Join Call</button>
    <br>
    <button id="gen-link">🔗 Générer lien invitation</button>
    <input id="invite-link" readonly style="width:100%;display:none">
    <p id="status"></p>
    <button id="screenshot">📸 Prendre capture</button>
  </div>

  <div id="chat">
    <h3>Chat</h3>
    <div id="messages"></div>
    <input id="msg-input" placeholder="Écrire un message…">
    <button id="send-msg">Envoyer</button>
  </div>
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', async () => {
  const peer = new Peer( {
  });
  const rotateCam   = document.getElementById('rotate-camera');
  const shareScreen = document.getElementById('share-screen');
  const joinBtn     = document.getElementById('join-btn');
  const genLinkBtn  = document.getElementById('gen-link');
  const inviteLink  = document.getElementById('invite-link');
  const localV      = document.getElementById('local-video');
  const remoteV     = document.getElementById('remote-video');
  const localLabel  = document.getElementById('local-label');
  const remoteLabel = document.getElementById('remote-label');
  const localMicIcon  = document.getElementById('local-mic');
  const remoteMicIcon = document.getElementById('remote-mic');
  const statusText  = document.getElementById('status');
  const msgIn       = document.getElementById('msg-input');
  const sendBtn     = document.getElementById('send-msg');
  const messages    = document.getElementById('messages');
  const screenshot  = document.getElementById('screenshot');
  const toggleAudio = document.getElementById('toggle-audio');
  const chatBox     = document.getElementById('chat');
  const fullscreenLocalBtn  = document.getElementById('fullscreen-local');
  const fullscreenRemoteBtn = document.getElementById('fullscreen-remote');
  const connectionStatus = document.getElementById('connection-status');
  const latencyEl        = document.getElementById('latency');
  const remoteMicStatus  = document.getElementById('remote-mic-status');

  // Bouton pour lever l’autoplay sur iOS
  let audioUnlockBtn;
  function ensureAudioUnlockButton() {
    if (audioUnlockBtn) return;
    audioUnlockBtn = document.createElement('button');
    audioUnlockBtn.textContent = "🔊 Activer le son";
    audioUnlockBtn.style.position = 'fixed';
    audioUnlockBtn.style.right = '16px';
    audioUnlockBtn.style.bottom = '16px';
    audioUnlockBtn.style.zIndex = 9999;
    audioUnlockBtn.addEventListener('click', () => {
      remoteV.muted = false;
      remoteV.play().catch(()=>{});
      audioUnlockBtn.remove();
    });
    document.body.appendChild(audioUnlockBtn);
  }

  const audioNotif = new Audio("https://www.soundjay.com/buttons/sounds/button-3.mp3");

  // ==== State ====
  let localStream = null;      // stream “source” (caméra ou écran + micro)
  let micTrack = null;         // on mémorise la track micro pour la mixer pendant le screen share
  let facingMode = 'user';
  let audioEnabled = true;
  let dataConn = null;         // PeerJS DataConnection (chat/ping)
  let mediaConn = null;        // PeerJS MediaConnection (appel)
  let isClient = false;

  // ==== URL role ====
  const url = new URL(window.location.href);
  const hostId = url.searchParams.get('host');
  isClient = Boolean(hostId);

  // ==== Helpers ====
  const isMobile = () => /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  function toast(message, type = 'info') {
    const el = document.createElement('div');
    el.textContent = message;
    el.style.position = 'fixed';
    el.style.bottom = '20px';
    el.style.left = '50%';
    el.style.transform = 'translateX(-50%)';
    el.style.padding = '10px 20px';
    el.style.borderRadius = '5px';
    el.style.color = '#fff';
    el.style.background = type === 'error' ? 'red' : type === 'warn' ? 'orange' : 'green';
    el.style.zIndex = 9999;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 3500);
  }

  function updateLocalMicIcon() {
    localMicIcon.textContent = audioEnabled ? '🎤' : '🔇';
  }
  function updateRemoteMicIcon(enabled) {
    remoteMicIcon.textContent = enabled ? '🎤' : '🔇';
  }
  function setRoleLabels() {
    // On évite childNodes[0] fragile
    localLabel.innerHTML  = (isClient ? 'Client '     : 'Technicien ') + `<span id="local-mic" class="mic-status">${audioEnabled?'🎤':'🔇'}</span>`;
    remoteLabel.innerHTML = (isClient ? 'Technicien ' : 'Client ')     + `<span id="remote-mic" class="mic-status">🎤</span>`;
  }

  async function stopStream(stream) {
    if (!stream) return;
    stream.getTracks().forEach(t => t.stop());
  }

  async function getUserMediaStream() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode },
      audio: true
    });
    // on isole/retient la track micro pour la réutiliser
    micTrack = stream.getAudioTracks()[0] || null;
    return stream;
  }

  async function setLocalStream(stream) {
    await stopStream(localStream);   // stoppe l’ancien stream proprement
    localStream = stream;
    localV.srcObject = stream;
    localV.muted = true; // éviter écho local
    updateLocalMicToggle();
  }

  function updateLocalMicToggle() {
    if (!micTrack) return;
    micTrack.enabled = audioEnabled;
    toggleAudio.textContent = audioEnabled ? '🔇 Couper micro' : '🎤 Activer micro';
    updateLocalMicIcon();
  }

  async function replaceOutgoingTrack(kind, newTrack) {
    if (!mediaConn || !mediaConn.peerConnection) return;
    const sender = mediaConn.peerConnection.getSenders().find(s => s.track && s.track.kind === kind);
    if (sender) {
      await sender.replaceTrack(newTrack);
    }
  }

  async function startCamera() {
    try {
      const cam = await getUserMediaStream();
      await setLocalStream(cam);
      statusText.textContent = 'Caméra/Micro activés';
      // si déjà en appel, remplace les tracks côté RTCRtpSender
      if (mediaConn && mediaConn.open) {
        const v = cam.getVideoTracks()[0];
        const a = micTrack;
        if (v) await replaceOutgoingTrack('video', v);
        if (a) await replaceOutgoingTrack('audio', a);
      }
    } catch (e) {
      console.warn(e);
      statusText.textContent = 'Accès caméra/micro refusé';
      toast('Erreur caméra/micro : ' + e.message, 'error');
    }
  }

  async function startScreenShare() {
    try {
      const display = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      // si l’audio d’écran n’est pas dispo, on garde le micro (micTrack)
      const screenVideo = display.getVideoTracks()[0] || null;
      const screenAudio = display.getAudioTracks()[0] || null;

      // on construit un “mix” local (vidéo = écran, audio = écran OU micro selon dispo)
      const mixed = new MediaStream();
      if (screenVideo) mixed.addTrack(screenVideo);
      if (screenAudio) {
        mixed.addTrack(screenAudio);
      } else if (micTrack) {
        mixed.addTrack(micTrack);
      }

      // quand l’utilisateur arrête le partage, on revient caméra
      screenVideo && screenVideo.addEventListener('ended', () => {
        startCamera();
      });

      await setLocalStream(mixed);
      statusText.textContent = 'Partage d’écran actif';

      if (mediaConn && mediaConn.open) {
        if (screenVideo) await replaceOutgoingTrack('video', screenVideo);
        // côté audio, on remplace par screenAudio si dispo sinon on garde micTrack
        const outAudio = screenAudio || micTrack;
        if (outAudio) await replaceOutgoingTrack('audio', outAudio);
      }
    } catch (e) {
      toast('Erreur partage d’écran : ' + e.message, 'error');
    }
  }

  function handleRemoteStream(stream) {
    remoteV.pause();
    remoteV.srcObject = null;
    remoteV.srcObject = stream;
    remoteV.playsInline = true;
    remoteV.muted = false;

    // iOS : proposer le bouton d’activation son si nécessaire
    if (isMobile()) ensureAudioUnlockButton();

    setTimeout(() => {
      remoteV.play().catch(err => console.warn('Lecture distante bloquée:', err));
    }, 200);

    chatBox.style.display = 'block';
    screenshot.style.display = 'inline-block';
    connectionStatus.textContent = '✅ Connecté à ' + (isClient ? 'Technicien' : 'Client');
    audioNotif.play().catch(()=>{});
    monitorRemoteMic(stream);
  }

  function monitorRemoteMic(stream) {
    const a = stream.getAudioTracks()[0];
    if (!a) return;
    const set = (on) => {
      remoteMicStatus.textContent = on ? "Micro distant : activé" : "Micro distant : coupé";
      updateRemoteMicIcon(on);
    };
    set(a.enabled);
    a.onmute   = () => set(false);
    a.onunmute = () => set(true);
  }

  function hideConnectionControls() {
    joinBtn.style.display = 'none';
    genLinkBtn.style.display = 'none';
    inviteLink.style.display = 'none';
  }

  function appendMessage(prefix, txt) {
    const el = document.createElement('div');
    el.textContent = `${prefix} : ${txt}`;
    messages.appendChild(el);
    messages.scrollTop = messages.scrollHeight;
  }

  function updatePingDisplay(ping) {
    latencyEl.textContent = `Ping : ${ping} ms`;
    latencyEl.className = ping < 100 ? 'ping-good' : ping < 200 ? 'ping-warn' : 'ping-bad';
  }

  // ==== UI events ====
  toggleAudio.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    updateLocalMicToggle();
  });

  rotateCam.addEventListener('click', async () => {
    facingMode = (facingMode === 'user' ? 'environment' : 'user');
    await startCamera();
  });

  shareScreen.addEventListener('click', startScreenShare);

  fullscreenLocalBtn.addEventListener('click', () => {
    (localV.requestFullscreen || localV.webkitRequestFullscreen || function(){})();
  });
  fullscreenRemoteBtn.addEventListener('click', () => {
    (remoteV.requestFullscreen || remoteV.webkitRequestFullscreen || function(){})();
  });

  sendBtn.addEventListener('click', () => {
    const text = msgIn.value.trim();
    if (dataConn && dataConn.open && text) {
      dataConn.send(text);
      appendMessage(isClient ? 'Client' : 'Technicien', text);
      msgIn.value = '';
    }
  });

  genLinkBtn.addEventListener('click', async () => {
    const base = window.location.origin + window.location.pathname;
    const link = `${base}?host=${peer.id}`;
    inviteLink.value = link;
    inviteLink.style.display = 'block';
    try {
      if (navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(link);
      } else {
        inviteLink.select();
        document.execCommand('copy');
      }
      toast('Lien d’invitation copié !', 'info');
    } catch {
      toast('Copie impossible. Copiez le lien manuellement.', 'warn');
    }
  });

  document.getElementById('screenshot').addEventListener('click', async () => {
    const canvas = await html2canvas(document.body);
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'screenshot.png';
    a.click();
  });

  // ==== Connexion logique ====
  joinBtn.addEventListener('click', () => initCall(hostId));

  async function initCall(remoteId) {
    if (!remoteId || !peer.open) return toast('ID invalide ou Peer non connecté', 'error');
    if (!localStream) await startCamera();

    mediaConn = peer.call(remoteId, localStream);         // appel média
    dataConn  = peer.connect(remoteId);                   // data channel

    let timeout = setTimeout(() => {
      if (!dataConn?.open && !mediaConn?.open) {
        toast('⏳ Temps de connexion dépassé.', 'error');
        connectionStatus.textContent = "❌ Connexion échouée.";
        peer.disconnect();
      }
    }, 12000);

    mediaConn.on('stream', handleRemoteStream);
    mediaConn.on('error', e => toast('Erreur appel : ' + e, 'error'));

    dataConn.on('open', () => {
      clearTimeout(timeout);
      hideConnectionControls();
      connectionStatus.textContent = '✅ Connecté à ' + (isClient ? 'Technicien' : 'Client');
      audioNotif.play().catch(()=>{});
    });
    dataConn.on('data', handleConnData);
    dataConn.on('error', e => toast('Erreur data : ' + e, 'error'));
  }

  function handleConnData(data) {
    if (typeof data === 'string') appendMessage(isClient ? 'Technicien' : 'Client', data);
    if (data?.type === 'ping' && dataConn?.open) dataConn.send({ type: 'pong', time: data.time });
    if (data?.type === 'pong') {
      const ping = Date.now() - data.time;
      updatePingDisplay(ping);
    }
  }

  // ==== Peer events (réception) ====
  peer.on('open', async id => {
    setRoleLabels();
    if (isClient) {
      genLinkBtn.style.display = 'none';
      joinBtn.style.display = 'inline-block';
    }
    await startCamera();
  });

  peer.on('call', async incomingCall => {
    mediaConn = incomingCall;
    if (!localStream) await startCamera();
    mediaConn.answer(localStream, { metadata: { audio: true, video: true } });
    mediaConn.on('stream', handleRemoteStream);
    mediaConn.on('error', e => toast('Erreur appel : ' + e, 'error'));
  });

  peer.on('connection', c => {
    dataConn = c;
    dataConn.on('open', () => {
      hideConnectionControls();
      connectionStatus.textContent = '✅ Connecté à ' + (isClient ? 'Technicien' : 'Client');
      audioNotif.play().catch(()=>{});
    });
    dataConn.on('data', handleConnData);
    dataConn.on('error', e => toast('Erreur data : ' + e, 'error'));
  });

  peer.on('disconnected', () => {
    toast('⚡ Connexion perdue. Tentative de reconnexion...', 'warn');
    peer.reconnect();
  });

  peer.on('error', err => {
    console.error(err);
    toast('Peer error: ' + err.type, 'error');
  });

  // Ping périodique
  setInterval(() => {
    if (dataConn?.open) dataConn.send({ type: 'ping', time: Date.now() });
  }, 3000);
});
</script>

</body>
</html>
