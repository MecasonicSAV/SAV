<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MECASONIC ‚Ä¢ Support vid√©o</title>
  <link rel="preconnect" href="https://unpkg.com" />
  <style>
    :root{
      --bg:#0f1115; --bg-soft:#151823; --panel:#161a25; --text:#e8ecf1; --muted:#9aa3b2;
      --brand:#6aa6ff; --brand-2:#5ef0c1; --danger:#ff6b6b; --warn:#ffb020; --ok:#50d18a;
      --border: rgba(255,255,255,.08); --shadow: 0 8px 30px rgba(0,0,0,.35); --radius:16px;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f5f7fb; --bg-soft:#fff; --panel:#fff; --text:#101318; --muted:#5b6270;
             --border:rgba(16,19,24,.08); --shadow:0 6px 24px rgba(0,0,0,.08); }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
         background:linear-gradient(180deg,var(--bg) 0%,var(--bg-soft) 100%); color:var(--text);} 

    /* Topbar */
    .topbar{position:sticky; top:0; z-index:50; backdrop-filter:saturate(1.2) blur(8px);
      background:linear-gradient(90deg,rgba(106,166,255,.08),rgba(94,240,193,.08));
      border-bottom:1px solid var(--border);} 
    .topbar-inner{max-width:1200px;margin:0 auto;display:flex;align-items:center;gap:14px;padding:10px 16px;} 
    .brand{display:flex;align-items:center;gap:10px;font-weight:700;} 
    .badge{font-size:12px;padding:4px 8px;border:1px solid var(--border);border-radius:9999px;background:rgba(255,255,255,.05);color:var(--muted);} 
    .status-line{margin-left:auto;display:flex;align-items:center;gap:12px;font-size:14px;} 
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;box-shadow:0 0 0 3px rgba(255,255,255,.06) inset;} 
    .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--danger)} .dot.idle{background:#8a8f9b} 

    /* Layout */
    .container{max-width:1200px;margin:24px auto;padding:0 16px 100px;display:grid;grid-template-columns: 1fr 340px;gap:16px;} 
    @media (max-width: 980px){ .container{ grid-template-columns:1fr; } } 

    /* Panel */
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;} 
    .panel-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border);} 
    .panel-title{display:flex;align-items:center;gap:10px;font-weight:600;} 
    .role{font-size:12px;color:var(--muted);} 

    .video-area{position:relative;aspect-ratio:16/9;background:#0b0e14;display:grid;place-items:center;overflow:hidden;} 
    video{width:100%;height:100%;object-fit:cover;background:#000;touch-action:none;} /* touch-action none pour pinch/pan custom */

    .vid-badges{position:absolute;top:10px;left:10px;display:flex;gap:8px;z-index:3;} 
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:rgba(0,0,0,.35);} 

    /* Controls */
    .controls{display:flex;align-items:center;flex-wrap:wrap;gap:10px;padding:12px;border-top:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.02),transparent);} 
    .btn{appearance:none;border:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.06));color:var(--text);padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:8px;box-shadow:0 2px 0 rgba(0,0,0,.2);} 
    .btn:hover{filter:brightness(1.06)} .btn:active{transform:translateY(1px)} .btn.primary{border-color:transparent;background:linear-gradient(90deg,var(--brand),var(--brand-2));color:#0b0e14;} 
    .btn.ghost{background:transparent;} 

    .controls .spacer{flex:1}
    /* Panneau p√©riph√©riques (√† droite) */
    .devices-wrap{margin-left:auto;position:relative;}
    .devices-panel{
      position:absolute; right:0; top:110%;
      background:var(--panel); border:1px solid var(--border); border-radius:12px;
      box-shadow:var(--shadow); padding:10px; display:none; width:min(88vw, 360px); z-index:20;
    }
    .devices-panel.open{display:block;}
    .devices-panel .row{display:flex; gap:8px; margin:6px 0;}
    .devices-panel select{flex:1; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:rgba(255,255,255,.04); color:var(--text);}

    /* Sidebar */
    .side{display:flex;flex-direction:column;gap:12px;} 
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;} 
    .card-header{padding:10px 12px;border-bottom:1px solid var(--border);font-weight:700;} 
    .chat-log{height:280px;overflow:auto;padding:10px 12px;font-size:14px;display:flex;flex-direction:column;gap:6px;} 
    .msg{padding:8px 10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:10px;} 
    .chat-input{display:flex;gap:8px;padding:10px;} .chat-input input{flex:1;} 

    /* Toasts */
    .toasts{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;gap:8px;z-index:100;} 
    .toast{padding:10px 14px;border-radius:12px;color:#0b0e14;background:#d1f2e3;box-shadow:var(--shadow);border:1px solid rgba(0,0,0,.06);font-weight:700;} 
    .toast.warn{background:#ffeac2} .toast.error{background:#ffd6d6} 

    /* Dock mobile */
    .dock{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:rgba(15,17,21,.6);border:1px solid var(--border);border-radius:9999px;padding:8px;display:flex;gap:8px;box-shadow:var(--shadow);backdrop-filter:blur(8px);z-index:60;} 
    .dock .btn{padding:10px 12px;} 
    @media (min-width:980px){ .dock{display:none;} } 

    .hidden{display:none !important;} 

    /* ---- Vignettes cliquables ---- */
    .thumbs{
      position:absolute; left:12px; right:12px; bottom:12px;
      display:flex; gap:8px; padding:8px;
      background:rgba(0,0,0,.28); border:1px solid var(--border);
      border-radius:12px; overflow:auto; z-index:5;
    }
    .thumb{
      position:relative; width:140px; aspect-ratio:16/9;
      border:1px solid var(--border); border-radius:10px; overflow:hidden; cursor:pointer;
      box-shadow:var(--shadow); flex:0 0 auto; outline:2px solid transparent; outline-offset:0;
    }
    .thumb.active{ outline-color: var(--brand-2); }
    .thumb video{ width:100%; height:100%; object-fit:cover; background:#000; }
    .thumb .name{
      position:absolute; left:6px; bottom:6px; font-size:12px; padding:2px 6px;
      border-radius:999px; background:rgba(0,0,0,.45); border:1px solid var(--border);
    }
  </style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="topbar-inner" aria-live="polite">
      <div class="brand" title="MECASONIC Support Vid√©o">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 12a8 8 0 1 1 16 0" stroke="currentColor" stroke-width="2"/><path d="M12 4v8l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        MECASONIC <span class="badge">Support vid√©o</span>
      </div>
      <div class="status-line">
        <span id="conn-dot" class="dot idle" aria-hidden="true"></span>
        <span id="connection-status">En attente‚Ä¶</span>
        <span aria-hidden="true">‚Ä¢</span><span id="latency">Ping : ‚Ä¶</span>
        <!-- micro distant retir√© -->
      </div>
    </div>
  </header>

  <main class="container">
    <section class="panel" aria-label="Zone vid√©o">
      <div class="panel-header">
        <div class="panel-title">
          <span id="main-role">Technicien</span>
          <span class="role" id="sub-role">Appel en attente</span>
        </div>
        <div>
          <button class="btn ghost" id="btn-fullscreen" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
      </div>

      <div class="video-area" id="video-area">
        <div class="vid-badges">
          <!-- badge micro distant retir√© -->
          <span class="chip" id="sharing-chip" style="display:none">üñ•Ô∏è Partage d‚Äô√©cran</span>
        </div>

        <!-- Grand canvas -->
        <video id="main-video" autoplay playsinline muted></video>

        <!-- Vignettes -->
        <div id="thumbs" class="thumbs"></div>
      </div>

      <div class="controls" id="controls">
        <!-- √Ä gauche (actions session) -->
        <button class="btn primary" id="btn-invite">üîó Inviter</button>
        <button class="btn hidden" id="btn-join">Rejoindre</button>
        <button class="btn" id="btn-hang" style="display:none">‚õî Raccrocher</button>

        <div class="field" id="invite-field" style="display:none">
          <input type="text" id="invite-link" readonly aria-label="Lien d‚Äôinvitation" />
          <button class="btn" id="btn-copy">Copier</button>
          <button class="btn" id="btn-share" title="Partager">Partager</button>
        </div>

        <span class="spacer"></span>

        <!-- √Ä droite (p√©riph√©riques rang√©s) -->
        <div class="devices-wrap">
          <button class="btn" id="btn-devices">‚öôÔ∏è P√©riph√©riques</button>
          <div class="devices-panel" id="devices-panel">
            <div class="row"><select id="mic-select" title="Micro"></select></div>
            <div class="row"><select id="spk-select" title="Haut-parleur (si support√©)"></select></div>
            <div class="row"><select id="cam-select" title="Cam√©ra"></select></div>
          </div>
        </div>

        <!-- Audio & partage -->
        <button class="btn" id="btn-toggle-audio">üîá Couper micro</button>
        <button class="btn" id="btn-share-screen">üñ•Ô∏è Partager √©cran</button>
      </div>
    </section>

    <aside class="side" aria-label="Barre lat√©rale">
      <div class="card">
        <div class="card-header">Chat</div>
        <div class="chat-log" id="messages" aria-live="polite"></div>
        <div class="chat-input">
          <input id="msg-input" placeholder="√âcrire un message‚Ä¶" />
          <button class="btn" id="btn-send">Envoyer</button>
        </div>
      </div>

      <!-- Carte "Statut" supprim√©e -->
    </aside>
  </main>

  <!-- Dock mobile (retir√©: rotate & shot) -->
  <nav class="dock" aria-label="Raccourcis">
    <button class="btn" id="m-toggle-audio" title="Couper/activer le micro">üéôÔ∏è</button>
    <button class="btn" id="m-share" title="Partager √©cran">üñ•Ô∏è</button>
    <button class="btn" id="m-hang" title="Raccrocher">‚õî</button>
  </nav>

  <div class="toasts" id="toasts" aria-live="polite" aria-atomic="true"></div>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <!-- html2canvas supprim√© (plus de capture) -->
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ==== DOM ====
    const mainV   = document.getElementById('main-video');
    const thumbs  = document.getElementById('thumbs');

    const btnInvite = document.getElementById('btn-invite');
    const btnJoin   = document.getElementById('btn-join');
    const btnHang   = document.getElementById('btn-hang');
    const inviteField = document.getElementById('invite-field');
    const inviteInput = document.getElementById('invite-link');
    const btnCopy   = document.getElementById('btn-copy');
    const btnShare  = document.getElementById('btn-share');

    const btnToggleAudio = document.getElementById('btn-toggle-audio');
    const btnShareScreen = document.getElementById('btn-share-screen');
    const btnFullscreen = document.getElementById('btn-fullscreen');

    const btnDevices = document.getElementById('btn-devices');
    const devicesPanel = document.getElementById('devices-panel');
    const micSelect = document.getElementById('mic-select');
    const spkSelect = document.getElementById('spk-select');
    const camSelect = document.getElementById('cam-select');

    const mToggle = document.getElementById('m-toggle-audio');
    const mShare  = document.getElementById('m-share');
    const mHang   = document.getElementById('m-hang');

    const messages = document.getElementById('messages');
    const msgInput = document.getElementById('msg-input');
    const btnSend  = document.getElementById('btn-send');

    const connDot  = document.getElementById('conn-dot');
    const connStatus = document.getElementById('connection-status');
    const latencyEl = document.getElementById('latency');

    const mainRole = document.getElementById('main-role');
    const subRole  = document.getElementById('sub-role');

    // ==== Utils / UI ====
    const toasts = document.getElementById('toasts');
    function toast(txt, type=''){ const t=document.createElement('div'); t.className='toast'+(type?(' '+type):''); t.textContent=txt; toasts.appendChild(t); setTimeout(()=>t.remove(), 3200); }
    function setConn(state){ connDot.className = 'dot '+state; }
    function updatePing(ms){ latencyEl.textContent = `Ping : ${ms} ms`; setConn(ms<100?'ok': ms<220?'warn':'bad'); }
    function appendMsg(from, txt){ const el=document.createElement('div'); el.className='msg'; el.textContent = `${from} : ${txt}`; messages.appendChild(el); messages.scrollTop = messages.scrollHeight; }
    const ding = new Audio('https://www.soundjay.com/buttons/sounds/button-3.mp3');
    const isMobile = () => /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    // fermer panneau p√©riph√©riques au clic ext√©rieur
    document.addEventListener('click', (e)=>{
      if (!devicesPanel.contains(e.target) && e.target !== btnDevices) devicesPanel.classList.remove('open');
    });
    btnDevices.addEventListener('click', (e)=>{
      e.stopPropagation();
      devicesPanel.classList.toggle('open');
    });

    // ==== WebRTC / PeerJS state ====
    const ICE_SERVERS = [
      { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] },
      { urls: 'turn:openrelay.metered.ca:80',  username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
    ];

    const peer = new Peer({
      debug: 2,
      config: { iceServers: ICE_SERVERS, iceCandidatePoolSize: 1 }
    });

    let peerReady=false, isCalling=false, isSharing=false, displayVideoTrack=null;
    let localStream=null, micTrack=null, camTrack=null;
    let audioEnabled=true;

    // Multi-participants & anti-doublons
    const SELF_UUID = (() => {
      let u = localStorage.getItem('client_uuid');
      if(!u){ u = (crypto.randomUUID ? crypto.randomUUID() : String(Math.random())); localStorage.setItem('client_uuid', u); }
      return u;
    })();

    const mediaConns = new Map();    // peerId -> MediaConnection
    const dataConns  = new Map();    // peerId -> DataConnection
    const remoteVideos = new Map();  // peerId -> <video> (inclut 'self')
    const remoteAudios = new Map();  // peerId -> <audio> (jamais pour 'self')
    const peerIdByUuid = new Map();  // uuid -> peerId courant
    const lastSeen = new Map();      // peerId -> timestamp
    let currentMainPeerId = null;

    // R√¥le via URL
    const url = new URL(window.location.href);
    const hostId = url.searchParams.get('host');
    const isClient = Boolean(hostId);

    mainRole.textContent = isClient ? 'Client' : 'Technicien';
    subRole.textContent  = 'En attente de connexion';

    // ====== Hang up / teardown ======
    function hangUp(){
      // Fermer data+media conns
      for (const [, dc] of dataConns){ try{ dc.close(); }catch{} }
      for (const [, mc] of mediaConns){ try{ mc.close(); }catch{} }
      dataConns.clear(); mediaConns.clear();

      // Stopper tracks
      if (localStream){ localStream.getTracks().forEach(t=>{ try{t.stop()}catch{} }); }
      if (displayVideoTrack){ try{displayVideoTrack.stop()}catch{} }

      // Reset vid√©os
      for (const [, v] of remoteVideos){ try{ v.srcObject=null; }catch{} }
      remoteVideos.clear();
      remoteAudios.forEach(a=>{ try{a.srcObject=null; a.remove()}catch{} });
      remoteAudios.clear();

      // UI
      thumbs.innerHTML='';
      mainV.srcObject=null;
      currentMainPeerId=null;
      isSharing=false;
      connStatus.textContent='Termin√©e';
      setConn('idle');

      // Boutons
      if (isClient){
        btnJoin.classList.remove('hidden');
        btnJoin.style.display='inline-block';
        btnHang.style.display='none';
      }
      // Host: conserve Inviter visible; Hang reste possible si de nouveau appels se font
      toast('Appel raccroch√©');
    }

    // ==== Devices helpers ====
    async function populateDeviceLists(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const mics = devices.filter(d=>d.kind==='audioinput');
        const spks = devices.filter(d=>d.kind==='audiooutput');
        const cams = devices.filter(d=>d.kind==='videoinput');

        micSelect.innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label||'Micro'}</option>`).join('') || '<option>‚Äî</option>';
        camSelect.innerHTML = cams.map(d=>`<option value="${d.deviceId}">${d.label||'Cam√©ra'}</option>`).join('') || '<option>‚Äî</option>';

        if (typeof HTMLMediaElement.prototype.setSinkId === 'function' && spks.length){
          spkSelect.innerHTML = spks.map(d=>`<option value="${d.deviceId}">${d.label||'Haut-parleur'}</option>`).join('');
          spkSelect.disabled = false;
        } else {
          spkSelect.innerHTML = '<option>Sortie non support√©e</option>';
          spkSelect.disabled = true;
        }

        if (isMobile()){
          const back = cams.find(c => /back|rear|environment/i.test(c.label));
          if(back){ camSelect.value = back.deviceId; }
        }
      }catch(e){ /* ignore */ }
    }

    // ==== Media acquisition ====
    let selfThumbVideo = null; // vid√©o de notre vignette "Moi"

    async function startCamera(initial=false){
      const wantBackOnMobile = isMobile() && initial;
      let constraints = {
        video: wantBackOnMobile ? { facingMode: { ideal:'environment' } } : { facingMode: { ideal:'user' } },
        audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
      };

      if (camSelect.value) constraints.video = { deviceId: { exact: camSelect.value } };

      try{
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        camTrack = s.getVideoTracks()[0] || null;
        micTrack = s.getAudioTracks()[0] || micTrack || null;

        if (!localStream){
          localStream = new MediaStream();
        } else {
          localStream.getTracks().forEach(t=>localStream.removeTrack(t));
        }
        if (camTrack) localStream.addTrack(camTrack);
        if (micTrack) localStream.addTrack(micTrack);

        // met √† jour envois sortants
        for (const [, mc] of mediaConns){
          const v = camTrack, a = micTrack;
          if (v) await replaceOutgoing(mc, 'video', v);
          if (a) await replaceOutgoing(mc, 'audio', a);
        }

        // vignette locale
        buildSelfThumb();

        // si rien en principal, affiche "Moi"
        if (!currentMainPeerId){
          setMain('self');
        }

        subRole.textContent = wantBackOnMobile ? 'Cam√©ra arri√®re' : 'Cam√©ra pr√™te';
      }catch(e){
        toast('Acc√®s cam√©ra/micro refus√© : '+e.message, 'error');
      }
    }

    function buildSelfThumb(){
      let wrap = document.getElementById('thumb-self');
      if(!wrap){
        wrap = document.createElement('div');
        wrap.className = 'thumb';
        wrap.id = 'thumb-self';

        const v = document.createElement('video');
        v.autoplay = true; v.playsInline = true; v.controls = false;
        v.muted = true; // IMPORTANT: pas de retour son local
        v.id = 'remote-self';

        const name = document.createElement('div');
        name.className = 'name'; name.textContent = 'Moi';

        wrap.appendChild(v);
        wrap.appendChild(name);
        thumbs.prepend(wrap); // "Moi" en premier

        remoteVideos.set('self', v);
        selfThumbVideo = v;

        wrap.addEventListener('click', ()=> setMain('self'));
      }

      if (selfThumbVideo){
        selfThumbVideo.srcObject = localStream;
        selfThumbVideo.play().catch(()=>{});
      }
    }

    async function changeMic(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: deviceId }, echoCancellation:true, noiseSuppression:true, autoGainControl:true }, video:false });
        const newMic = s.getAudioTracks()[0];
        if (!newMic){ s.getTracks().forEach(t=>t.stop()); return; }

        const vids = localStream.getVideoTracks();
        if (micTrack){ try{ micTrack.stop(); }catch{} }
        micTrack = newMic;
        localStream = new MediaStream([...vids, micTrack]);

        if (selfThumbVideo){
          selfThumbVideo.srcObject = localStream;
          selfThumbVideo.play().catch(()=>{});
        }

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'audio', micTrack);
        }
      }catch(e){ toast('Changement de micro impossible : '+e.message, 'error'); }
    }

    async function changeSpeaker(deviceId){
      for (const [, audio] of remoteAudios){
        if (typeof audio.setSinkId === 'function'){
          try{ await audio.setSinkId(deviceId); }catch(e){ /* ignore */ }
        }
      }
    }

    async function changeCamera(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{ exact: deviceId } }, audio:false });
        const newCam = s.getVideoTracks()[0];
        if (!newCam){ s.getTracks().forEach(t=>t.stop()); return; }
        camTrack = newCam;

        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([camTrack, ...auds]);

        if (selfThumbVideo){
          selfThumbVideo.srcObject = localStream;
          selfThumbVideo.play().catch(()=>{});
        }

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', camTrack);
        }
      }catch(e){ toast('Changement de cam√©ra impossible : '+e.message,'error'); }
    }

    // ==== Screen share : remplace uniquement la vid√©o ====
    async function startShare(){
      if (isMobile()){
        toast('Le partage d‚Äô√©cran est disponible uniquement sur ordinateur.', 'warn');
        return;
      }
      try{
        if (isSharing){
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';
          await startCamera(false);
          return;
        }
        if (!navigator.mediaDevices.getDisplayMedia){ toast('Partage non support√© sur ce navigateur','warn'); return; }

        const disp = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false });
        const v = disp.getVideoTracks()[0];
        if (!v){ toast('Aucune piste vid√©o de partage','error'); return; }

        displayVideoTrack = v;
        sharingChip.style.display='inline-flex';
        isSharing=true; btnShareScreen.textContent='‚õî Arr√™ter partage'; mShare.textContent='‚õî';

        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([displayVideoTrack, ...auds]);

        if (selfThumbVideo){
          selfThumbVideo.srcObject = localStream;
          selfThumbVideo.play().catch(()=>{});
        }

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', displayVideoTrack);
        }

        displayVideoTrack.addEventListener('ended', async ()=>{
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';
          await startCamera(false);
        });

      }catch(e){ toast('Partage d‚Äô√©cran annul√©','warn'); }
    }

    // ==== Senders replace ====
    async function replaceOutgoing(mediaConn, kind, track){
      const pc = mediaConn?.peerConnection;
      if (!pc) return;
      const sender = pc.getSenders().find(s => s.track && s.track.kind === kind);
      if (sender){
        await sender.replaceTrack(track);
      } else {
        try { pc.addTrack(track, localStream); } catch {}
      }
    }

    // ==== Audio & vignettes ====
    function addRemoteAudio(peerId, stream){
      if (peerId === 'self') return; // jamais d'audio pour soi
      let a = remoteAudios.get(peerId);
      if(!a){
        a = document.createElement('audio');
        a.autoplay = true;
        a.controls = false;
        a.style.display = 'none';
        document.body.appendChild(a);
        remoteAudios.set(peerId, a);
      }
      a.srcObject = stream;
      a.muted = false;
      a.play().catch(()=>{});
      lastSeen.set(peerId, Date.now());
    }

    function buildThumb(peerId, stream, label='Participant'){
      let wrap = document.getElementById('thumb-'+peerId);
      if(!wrap){
        wrap = document.createElement('div');
        wrap.className = 'thumb';
        wrap.id = 'thumb-'+peerId;

        const v = document.createElement('video');
        v.autoplay = true; v.playsInline = true; v.controls = false;
        v.muted = true; // vignettes muettes
        v.id = 'remote-'+peerId;

        const name = document.createElement('div');
        name.className = 'name'; name.textContent = label;

        wrap.appendChild(v);
        wrap.appendChild(name);
        thumbs.appendChild(wrap);

        remoteVideos.set(peerId, v);

        wrap.addEventListener('click', ()=> setMain(peerId));
      }

      const vid = remoteVideos.get(peerId);
      vid.srcObject = stream;
      vid.play().catch(()=>{});
    }

    function setMain(peerId){
      if(peerId === currentMainPeerId) return;
      const v = remoteVideos.get(peerId);
      if(!v || !v.srcObject) return;

      mainV.srcObject = v.srcObject;
      mainV.muted = true; // on g√®re l'audio via <audio> cach√©s
      mainV.style.transform = 'translate(0,0) scale(1)'; // reset zoom si on change
      mainV.play().catch(()=>{});

      document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('active'));
      const active = document.getElementById('thumb-'+peerId);
      if(active) active.classList.add('active');

      currentMainPeerId = peerId;
    }

    function removePeerCompletely(peerId){
      // audio
      const a = remoteAudios.get(peerId);
      if(a){ try{ a.srcObject=null; a.remove(); }catch{} remoteAudios.delete(peerId); }

      // vignette
      const v = remoteVideos.get(peerId);
      if(v){ try{ v.srcObject=null; }catch{}; remoteVideos.delete(peerId); }
      const wrap = document.getElementById('thumb-'+peerId);
      if(wrap){ wrap.remove(); }

      // connexions
      const mc = mediaConns.get(peerId); if(mc){ try{ mc.close(); }catch{} mediaConns.delete(peerId); }
      const dc = dataConns.get(peerId);  if(dc){ try{ dc.close(); }catch{} dataConns.delete(peerId); }

      if(currentMainPeerId === peerId){
        currentMainPeerId = null;
        const next = [...remoteVideos.keys()][0];
        if(next) setMain(next); else { mainV.srcObject = null; }
      }

      lastSeen.delete(peerId);
      for (const [uuid, pid] of peerIdByUuid){
        if (pid === peerId) peerIdByUuid.delete(uuid);
      }
    }

    // ==== Chat ====
    btnSend.onclick = ()=>{
      const t = msgInput.value.trim(); if(!t) return;
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'chat', text:t}); }
      appendMsg('Moi', t); msgInput.value='';
    };

    // ==== Invite / Join / Hang UI ====
    btnInvite.onclick = ()=>{
      if(!peerReady){ toast('Initialisation en cours‚Ä¶', 'warn'); return; }
      const base = `${location.origin}${location.pathname}`;
      const link = `${base}?host=${encodeURIComponent(peer.id)}`;
      inviteInput.value = link; inviteField.style.display='flex';
      if(navigator.share && location.protocol === 'https:'){ btnShare.classList.remove('hidden'); }
    };
    btnCopy.onclick = async ()=>{ try{ await navigator.clipboard.writeText(inviteInput.value); toast('Lien copi√©'); }catch{ toast('Copie impossible','warn'); } };
    btnShare.onclick = async ()=>{ try{ await navigator.share({ title:'Rejoindre l‚Äôappel MECASONIC', url: inviteInput.value }); }catch{} };
    btnJoin.onclick = ()=> initCall(hostId);
    btnHang.onclick = ()=> hangUp();
    mHang.onclick   = ()=> hangUp();

    // ==== Buttons ====
    btnToggleAudio.onclick = ()=>{
      audioEnabled = !audioEnabled;
      if(micTrack){ micTrack.enabled = audioEnabled; }
      btnToggleAudio.textContent = audioEnabled? 'üîá Couper micro':'üé§ Activer micro';
    };
    btnShareScreen.onclick = ()=> startShare();
    btnFullscreen.onclick = ()=>{
      const el=document.getElementById('video-area');
      (el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen||(()=>{})).call(el);
    };

    // Dock mirrors
    mToggle.onclick = ()=>btnToggleAudio.click();
    mShare.onclick  = ()=>btnShareScreen.click();

    // D√©sactiver UI de partage d‚Äô√©cran sur mobile
    if (isMobile()){ btnShareScreen.style.display='none'; mShare.style.display='none'; }

    // ==== Device selectors bindings ====
    micSelect.onchange = (e)=> changeMic(e.target.value);
    camSelect.onchange = (e)=> changeCamera(e.target.value);
    spkSelect.onchange = (e)=> changeSpeaker(e.target.value);

    // ==== PeerJS events ====
    peer.on('open', async id=>{
      peerReady = true;
      if(isClient){
        // c√¥t√© client : join visible si pas encore connect√©
        btnInvite.style.display='none';
        btnJoin.classList.remove('hidden');
        btnJoin.style.display='inline-block';
      } else {
        // c√¥t√© host : inviter + raccrocher visibles
        btnInvite.style.display='inline-block';
        btnHang.style.display='inline-block';
      }

      await startCamera(true);
      await populateDeviceLists();

      if (isClient && hostId){ 
        await initCall(hostId);
      }
    });

    function broadcastPeersList(){
      const ids = Array.from(mediaConns.keys()).concat([peer.id]).filter(Boolean);
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'peers', ids}); }
    }

    function setupDataConn(dc){
      dataConns.set(dc.peer, dc);
      dc.on('open', ()=>{
        connStatus.textContent='Connect√©'; setConn('ok'); ding.play().catch(()=>{});
        dc.send({type:'hello', id: peer.id, uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien'});
        broadcastPeersList();

        // c√¥t√© client : une fois connect√©, remplacer Rejoindre par Raccrocher
        if (isClient){
          btnJoin.style.display='none';
          btnHang.style.display='inline-block';
        }
      });
      dc.on('close', ()=>{ removePeerCompletely(dc.peer); setConn('warn'); });
      dc.on('error', e=>toast('Erreur data: '+e,'error'));
      dc.on('data', payload=>{
        if (typeof payload === 'string'){ appendMsg(dc.peer, payload); return; }
        if (payload?.type === 'chat'){ appendMsg(dc.peer, payload.text); }
        if (payload?.type === 'peers' && isClient){
          const ids = (payload.ids||[]).filter(pid => pid && pid !== peer.id && !mediaConns.has(pid));
          for (const pid of ids){ callPeer(pid); }
        }
        if (payload?.type === 'hello'){
          if (payload.uuid){
            const existing = peerIdByUuid.get(payload.uuid);
            if (existing && existing !== dc.peer){
              removePeerCompletely(existing);
            }
            peerIdByUuid.set(payload.uuid, dc.peer);
          }
        }
        if (payload?.type === 'ping'){ dc.send({type:'pong', time:payload.time}); }
        if (payload?.type === 'pong'){ updatePing(Date.now()-payload.time); lastSeen.set(dc.peer, Date.now()); }
      });
    }

    peer.on('connection', c => setupDataConn(c));

    function setupMediaConn(mc){
      mediaConns.set(mc.peer, mc);
      mc.on('stream', stream => {
        buildThumb(mc.peer, stream, 'Participant');
        addRemoteAudio(mc.peer, stream);
        lastSeen.set(mc.peer, Date.now());
        if(!currentMainPeerId) setMain(mc.peer);
      });
      mc.on('close', ()=>{ removePeerCompletely(mc.peer); setConn('warn'); });
      mc.on('error', e=> toast('Erreur appel: '+e,'error'));

      mc.peerConnection?.addEventListener('iceconnectionstatechange', ()=>{
        const s = mc.peerConnection.iceConnectionState;
        if(s==='failed' || s==='disconnected'){ setConn('bad'); }
        if(s==='connected'){ setConn('ok'); }
      });
    }

    peer.on('call', async inc=>{
      if(!localStream) await startCamera(false);
      if (inc.metadata?.uuid){
        const existing = peerIdByUuid.get(inc.metadata.uuid);
        if (existing && existing !== inc.peer){
          removePeerCompletely(existing);
        }
        peerIdByUuid.set(inc.metadata.uuid, inc.peer);
      }
      inc.answer(localStream, { metadata:{ uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien' } });
      setupMediaConn(inc);
    });

    peer.on('disconnected', ()=>{ toast('Connexion signalisation perdue. Reconnexion‚Ä¶','warn'); peer.reconnect(); setConn('warn'); });
    peer.on('error', err=>{ console.error(err); toast('Peer error: '+err.type,'error'); setConn('bad'); });

    // ==== Init calls ====
    async function callPeer(remoteId){
      if (!peer.open || !remoteId) return;
      const mc = peer.call(remoteId, localStream, { metadata:{ uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien' } });
      setupMediaConn(mc);
      const dc = peer.connect(remoteId);
      setupDataConn(dc);
    }

    async function initCall(remoteId){
      if(isCalling){ toast('Connexion d√©j√† en cours‚Ä¶','warn'); return; }
      if(!remoteId || !peer.open){ toast('ID invalide ou Peer non connect√©','error'); return; }
      if(!localStream) await startCamera(false);

      isCalling = true;
      await callPeer(remoteId);

      setTimeout(()=>{ isCalling=false; }, 4000);
      connStatus.textContent='Connexion‚Ä¶';
    }

    // ==== Pings + purge anti-fant√¥mes ====
    setInterval(()=>{
      const now = Date.now();
      for (const [id, dc] of dataConns){
        if (dc.open){ dc.send({type:'ping', time:now}); }
      }
      for (const [peerId, t] of lastSeen){
        if (now - t > 12000){
          removePeerCompletely(peerId);
        }
      }
    }, 3000);

    // ==== Speaker select hint ====
    if (!(typeof HTMLMediaElement.prototype.setSinkId === 'function')){
      spkSelect.title = 'Changement de sortie non support√© par ce navigateur';
    }

    // ====== Pinch-to-zoom en plein √©cran (mobile) ======
    let scale=1, lastDist=0, lastCenter=[0,0], panX=0, panY=0;
    function dist(p1,p2){ const dx=p1.clientX-p2.clientX, dy=p1.clientY-p2.clientY; return Math.hypot(dx,dy); }
    function center(p1,p2){ return [(p1.clientX+p2.clientX)/2,(p1.clientY+p2.clientY)/2]; }

    function applyTransform(){
      mainV.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      mainV.style.transformOrigin = 'center center';
    }

    document.addEventListener('fullscreenchange', ()=>{
      // reset √† l‚Äôentr√©e/sortie si n√©cessaire
      if (!document.fullscreenElement){
        scale=1; panX=0; panY=0; applyTransform();
      }
    });

    // Gestes tactiles
    let dragging=false, prevX=0, prevY=0;
    mainV.addEventListener('touchstart', (e)=>{
      if (!document.fullscreenElement) return;
      if (e.touches.length===2){
        lastDist = dist(e.touches[0], e.touches[1]);
        lastCenter = center(e.touches[0], e.touches[1]);
      } else if (e.touches.length===1){
        dragging=true; prevX=e.touches[0].clientX; prevY=e.touches[0].clientY;
      }
    }, {passive:false});

    mainV.addEventListener('touchmove', (e)=>{
      if (!document.fullscreenElement) return;
      if (e.touches.length===2){
        const d = dist(e.touches[0], e.touches[1]);
        if (lastDist){
          const factor = d / lastDist;
          scale = Math.min(6, Math.max(1, scale * factor));
          // pan pour garder la zone sous les doigts visible (approx simple)
          const c = center(e.touches[0], e.touches[1]);
          panX += (c[0]-lastCenter[0]) * 0.8;
          panY += (c[1]-lastCenter[1]) * 0.8;
          lastCenter = c;
          lastDist = d;
          applyTransform();
        }
        e.preventDefault();
      } else if (e.touches.length===1 && dragging){
        const x=e.touches[0].clientX, y=e.touches[0].clientY;
        panX += (x-prevX); panY += (y-prevY);
        prevX=x; prevY=y;
        applyTransform();
        e.preventDefault();
      }
    }, {passive:false});

    mainV.addEventListener('touchend', (e)=>{
      if (!document.fullscreenElement) return;
      if (e.touches.length<2) lastDist=0;
      if (e.touches.length===0) dragging=false;
    });

    // Double-tap pour reset
    let lastTap=0;
    mainV.addEventListener('touchend', ()=>{
      const now=Date.now();
      if (now-lastTap<300 && document.fullscreenElement){
        scale=1; panX=0; panY=0; applyTransform();
      }
      lastTap=now;
    });
  });
  </script>
</body>
</html>
