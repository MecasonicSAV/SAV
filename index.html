<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MECASONIC ‚Ä¢ Support vid√©o</title>
  <link rel="preconnect" href="https://unpkg.com" />
  <style>
    :root{
      --bg:#0f1115; --bg-soft:#151823; --panel:#161a25; --text:#e8ecf1; --muted:#9aa3b2;
      --brand:#6aa6ff; --brand-2:#5ef0c1; --danger:#ff6b6b; --warn:#ffb020; --ok:#50d18a;
      --border: rgba(255,255,255,.08); --shadow: 0 8px 30px rgba(0,0,0,.35); --radius:16px;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f5f7fb; --bg-soft:#fff; --panel:#fff; --text:#101318; --muted:#5b6270;
             --border:rgba(16,19,24,.08); --shadow:0 6px 24px rgba(0,0,0,.08); }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
         background:linear-gradient(180deg,var(--bg) 0%,var(--bg-soft) 100%); color:var(--text);} 

    /* Topbar */
    .topbar{position:sticky; top:0; z-index:50; backdrop-filter:saturate(1.2) blur(8px);
      background:linear-gradient(90deg,rgba(106,166,255,.08),rgba(94,240,193,.08));
      border-bottom:1px solid var(--border);} 
    .topbar-inner{max-width:1200px;margin:0 auto;display:flex;align-items:center;gap:14px;padding:10px 16px;} 
    .brand{display:flex;align-items:center;gap:10px;font-weight:700;} 
    .badge{font-size:12px;padding:4px 8px;border:1px solid var(--border);border-radius:9999px;background:rgba(255,255,255,.05);color:var(--muted);} 
    .status-line{margin-left:auto;display:flex;align-items:center;gap:12px;font-size:14px;} 
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;box-shadow:0 0 0 3px rgba(255,255,255,.06) inset;} 
    .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--danger)} .dot.idle{background:#8a8f9b} 

    /* Layout */
    .container{max-width:1200px;margin:24px auto;padding:0 16px 100px;display:grid;grid-template-columns: 1fr 340px;gap:16px;} 
    @media (max-width: 980px){ .container{ grid-template-columns:1fr; } } 

    /* Panel */
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;} 
    .panel-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border);} 
    .panel-title{display:flex;align-items:center;gap:10px;font-weight:600;} 
    .role{font-size:12px;color:var(--muted);} 

    .video-area{position:relative;aspect-ratio:16/9;background:#0b0e14;display:grid;place-items:center;overflow:hidden;} 
    video{width:100%;height:100%;object-fit:cover;background:#000;} 

    .vid-badges{position:absolute;top:10px;left:10px;display:flex;gap:8px;z-index:3;} 
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:rgba(0,0,0,.35);} 
    .local-thumb{position:absolute;right:12px;bottom:12px;width:220px;max-width:35%;aspect-ratio:16/9;border:1px solid var(--border);border-radius:12px;overflow:hidden;cursor:pointer;box-shadow:var(--shadow);z-index:4;} 
    .local-thumb video{width:100%;height:100%;object-fit:cover;} 
    @media (max-width:720px){ .local-thumb{ width:140px; } } 

    /* Controls */
    .controls{display:flex;flex-wrap:wrap;gap:10px;padding:12px;border-top:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.02),transparent);} 
    .btn{appearance:none;border:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.06));color:var(--text);padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:8px;box-shadow:0 2px 0 rgba(0,0,0,.2);} 
    .btn:hover{filter:brightness(1.06)} .btn:active{transform:translateY(1px)} .btn.primary{border-color:transparent;background:linear-gradient(90deg,var(--brand),var(--brand-2));color:#0b0e14;} 
    .btn.ghost{background:transparent;} 
    .field{display:flex;gap:8px;width:100%;} 
    input[type="text"], input[readonly], select{flex:1;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.04);color:var(--text);} 

    /* Sidebar */
    .side{display:flex;flex-direction:column;gap:12px;} 
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;} 
    .card-header{padding:10px 12px;border-bottom:1px solid var(--border);font-weight:700;} 
    .chat-log{height:280px;overflow:auto;padding:10px 12px;font-size:14px;display:flex;flex-direction:column;gap:6px;} 
    .msg{padding:8px 10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:10px;} 
    .chat-input{display:flex;gap:8px;padding:10px;} .chat-input input{flex:1;} 

    /* Toasts */
    .toasts{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;gap:8px;z-index:100;} 
    .toast{padding:10px 14px;border-radius:12px;color:#0b0e14;background:#d1f2e3;box-shadow:var(--shadow);border:1px solid rgba(0,0,0,.06);font-weight:700;} 
    .toast.warn{background:#ffeac2} .toast.error{background:#ffd6d6} 

    /* Dock mobile */
    .dock{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:rgba(15,17,21,.6);border:1px solid var(--border);border-radius:9999px;padding:8px;display:flex;gap:8px;box-shadow:var(--shadow);backdrop-filter:blur(8px);z-index:60;} 
    .dock .btn{padding:10px 12px;} 
    @media (min-width:980px){ .dock{display:none;} } 

    .hidden{display:none !important;} 

    /* ---- Vignettes cliquables ---- */
    .thumbs{
      position:absolute; left:12px; right:12px; bottom:12px;
      display:flex; gap:8px; padding:8px;
      background:rgba(0,0,0,.28); border:1px solid var(--border);
      border-radius:12px; overflow:auto; z-index:5;
    }
    .thumb{
      position:relative; width:140px; aspect-ratio:16/9;
      border:1px solid var(--border); border-radius:10px; overflow:hidden; cursor:pointer;
      box-shadow:var(--shadow); flex:0 0 auto; outline:2px solid transparent; outline-offset:0;
    }
    .thumb.active{ outline-color: var(--brand-2); }
    .thumb video{ width:100%; height:100%; object-fit:cover; background:#000; }
    .thumb .name{
      position:absolute; left:6px; bottom:6px; font-size:12px; padding:2px 6px;
      border-radius:999px; background:rgba(0,0,0,.45); border:1px solid var(--border);
    }
  </style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="topbar-inner" aria-live="polite">
      <div class="brand" title="MECASONIC Support Vid√©o">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 12a8 8 0 1 1 16 0" stroke="currentColor" stroke-width="2"/><path d="M12 4v8l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        MECASONIC <span class="badge">Support vid√©o</span>
      </div>
      <div class="status-line">
        <span id="conn-dot" class="dot idle" aria-hidden="true"></span>
        <span id="connection-status">En attente‚Ä¶</span>
        <span aria-hidden="true">‚Ä¢</span><span id="latency">Ping : ‚Ä¶</span>
        <span aria-hidden="true">‚Ä¢</span><span id="remote-mic-status">Micro distant : inconnu</span>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="panel" aria-label="Zone vid√©o">
      <div class="panel-header">
        <div class="panel-title">
          <span id="main-role">Technicien</span>
          <span class="role" id="sub-role">Appel en attente</span>
        </div>
        <div>
          <button class="btn ghost" id="btn-fullscreen" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
      </div>

      <div class="video-area" id="video-area">
        <div class="vid-badges">
          <span class="chip" id="remote-mic-chip">üé§ Micro</span>
          <span class="chip" id="sharing-chip" style="display:none">üñ•Ô∏è Partage d‚Äô√©cran</span>
        </div>

        <!-- Grand canvas (le participant s√©lectionn√©) -->
        <video id="main-video" autoplay playsinline muted></video>

        <!-- Vignette locale (PIP) -->
        <div class="local-thumb" id="local-thumb" title="Aper√ßu local (muet)">
          <video id="local-video" autoplay muted playsinline></video>
        </div>

        <!-- Rang√©e de vignettes cliquables -->
        <div id="thumbs" class="thumbs"></div>
      </div>

      <div class="controls" id="controls">
        <button class="btn primary" id="btn-invite">üîó Inviter</button>
        <button class="btn" id="btn-join" style="display:none">Rejoindre</button>

        <div class="field" id="invite-field" style="display:none">
          <input type="text" id="invite-link" readonly aria-label="Lien d‚Äôinvitation" />
          <button class="btn" id="btn-copy">Copier</button>
          <button class="btn" id="btn-share" title="Partager">Partager</button>
        </div>

        <span style="flex:1"></span>

        <!-- S√©lecteurs p√©riph√©riques -->
        <select id="mic-select" title="Micro"></select>
        <select id="spk-select" title="Haut-parleur (si support√©)"></select>
        <select id="cam-select" title="Cam√©ra"></select>

        <button class="btn" id="btn-toggle-audio">üîá Couper micro</button>
        <button class="btn" id="btn-rotate">‚Ü∫ Inverser cam√©ra</button>
        <button class="btn" id="btn-share-screen">üñ•Ô∏è Partager √©cran</button>
        <button class="btn" id="btn-shot">üì∏ Capture</button>
      </div>
    </section>

    <aside class="side" aria-label="Barre lat√©rale">
      <div class="card">
        <div class="card-header">Chat</div>
        <div class="chat-log" id="messages" aria-live="polite"></div>
        <div class="chat-input">
          <input id="msg-input" placeholder="√âcrire un message‚Ä¶" />
          <button class="btn" id="btn-send">Envoyer</button>
        </div>
      </div>

      <div class="card">
        <div class="card-header">Statut</div>
        <div style="padding:10px 12px; color:var(--muted)" id="status">‚Äî</div>
      </div>
    </aside>
  </main>

  <nav class="dock" aria-label="Raccourcis">
    <button class="btn" id="m-toggle-audio" title="Couper/activer le micro">üéôÔ∏è</button>
    <button class="btn" id="m-rotate" title="Changer de cam√©ra">‚Ü∫</button>
    <button class="btn" id="m-share" title="Partager √©cran">üñ•Ô∏è</button>
    <button class="btn" id="m-shot" title="Capture">üì∏</button>
  </nav>

  <div class="toasts" id="toasts" aria-live="polite" aria-atomic="true"></div>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ==== DOM ====
    const mainV   = document.getElementById('main-video');
    const thumbs  = document.getElementById('thumbs');
    const localV  = document.getElementById('local-video');
    const localThumb = document.getElementById('local-thumb');

    const btnInvite = document.getElementById('btn-invite');
    const btnJoin   = document.getElementById('btn-join');
    const inviteField = document.getElementById('invite-field');
    const inviteInput = document.getElementById('invite-link');
    const btnCopy   = document.getElementById('btn-copy');
    const btnShare  = document.getElementById('btn-share');

    const btnToggleAudio = document.getElementById('btn-toggle-audio');
    const btnRotate = document.getElementById('btn-rotate');
    const btnShareScreen = document.getElementById('btn-share-screen');
    const btnShot = document.getElementById('btn-shot');
    const btnFullscreen = document.getElementById('btn-fullscreen');

    const micSelect = document.getElementById('mic-select');
    const spkSelect = document.getElementById('spk-select');
    const camSelect = document.getElementById('cam-select');

    const mToggle = document.getElementById('m-toggle-audio');
    const mRotate = document.getElementById('m-rotate');
    const mShare  = document.getElementById('m-share');
    const mShot   = document.getElementById('m-shot');

    const messages = document.getElementById('messages');
    const msgInput = document.getElementById('msg-input');
    const btnSend  = document.getElementById('btn-send');

    const connDot  = document.getElementById('conn-dot');
    const connStatus = document.getElementById('connection-status');
    const latencyEl = document.getElementById('latency');
    const remoteMicStatus = document.getElementById('remote-mic-status');
    const remoteMicChip   = document.getElementById('remote-mic-chip');
    const sharingChip     = document.getElementById('sharing-chip');
    const statusText = document.getElementById('status');

    const mainRole = document.getElementById('main-role');
    const subRole  = document.getElementById('sub-role');

    // ==== Utils / UI ====
    const toasts = document.getElementById('toasts');
    function toast(txt, type=''){ const t=document.createElement('div'); t.className='toast'+(type?(' '+type):''); t.textContent=txt; toasts.appendChild(t); setTimeout(()=>t.remove(), 3200); }
    function setConn(state){ connDot.className = 'dot '+state; }
    function updatePing(ms){ latencyEl.textContent = `Ping : ${ms} ms`; setConn(ms<100?'ok': ms<220?'warn':'bad'); }
    function appendMsg(from, txt){ const el=document.createElement('div'); el.className='msg'; el.textContent = `${from} : ${txt}`; messages.appendChild(el); messages.scrollTop = messages.scrollHeight; }
    const ding = new Audio('https://www.soundjay.com/buttons/sounds/button-3.mp3');
    const isMobile = () => /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    // ==== WebRTC / PeerJS state ====
    const ICE_SERVERS = [
      { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] },
      // TURN publics pour test ‚Äî remplace par ton propre TURN en production
      { urls: 'turn:openrelay.metered.ca:80',  username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
    ];

    // *** PATCH: utiliser le cloud PeerJS (aucun host/port/path custom) ***
    const peer = new Peer({
      debug: 2,
      config: { iceServers: ICE_SERVERS, iceCandidatePoolSize: 1 }
      // secure est g√©r√© automatiquement selon la page (https)
    });

    let peerReady=false, isCalling=false, isSharing=false, displayVideoTrack=null;
    let localStream=null, micTrack=null, camTrack=null;
    let audioEnabled=true;

    // Multi-participants & anti-doublons
    const SELF_UUID = (() => {
      let u = localStorage.getItem('client_uuid');
      if(!u){ u = (crypto.randomUUID ? crypto.randomUUID() : String(Math.random())); localStorage.setItem('client_uuid', u); }
      return u;
    })();

    const mediaConns = new Map();    // peerId -> MediaConnection
    const dataConns  = new Map();    // peerId -> DataConnection
    const remoteVideos = new Map();  // peerId -> <video> (vignette)
    const remoteAudios = new Map();  // peerId -> <audio> (audio r√©el)
    const peerIdByUuid = new Map();  // uuid -> peerId courant
    const lastSeen = new Map();      // peerId -> timestamp (pong vu)
    let currentMainPeerId = null;

    // R√¥le via URL
    const url = new URL(window.location.href);
    const hostId = url.searchParams.get('host');
    const isClient = Boolean(hostId);

    mainRole.textContent = isClient ? 'Client' : 'Technicien';
    subRole.textContent  = 'En attente de connexion';

    // ==== Devices helpers ====
    async function populateDeviceLists(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const mics = devices.filter(d=>d.kind==='audioinput');
        const spks = devices.filter(d=>d.kind==='audiooutput');
        const cams = devices.filter(d=>d.kind==='videoinput');

        micSelect.innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label||'Micro'}</option>`).join('') || '<option>‚Äî</option>';
        camSelect.innerHTML = cams.map(d=>`<option value="${d.deviceId}">${d.label||'Cam√©ra'}</option>`).join('') || '<option>‚Äî</option>';

        if (typeof HTMLMediaElement.prototype.setSinkId === 'function' && spks.length){
          spkSelect.innerHTML = spks.map(d=>`<option value="${d.deviceId}">${d.label||'Haut-parleur'}</option>`).join('');
          spkSelect.disabled = false;
        } else {
          spkSelect.innerHTML = '<option>Sortie non support√©e</option>';
          spkSelect.disabled = true;
        }

        if (isMobile()){
          const back = cams.find(c => /back|rear|environment/i.test(c.label));
          if(back){ camSelect.value = back.deviceId; }
        }
      }catch(e){ /* ignore */ }
    }

    async function getDeviceIdForFacing(target){ // 'user'|'environment'
      try{
        const devs = await navigator.mediaDevices.enumerateDevices();
        const cams = devs.filter(d=>d.kind==='videoinput');
        const found = cams.find(c => {
          const L=(c.label||'').toLowerCase();
          return target==='environment' ? /(back|rear|environment)/.test(L) : /(front|user|face)/.test(L);
        });
        return found?.deviceId || null;
      }catch{ return null; }
    }

    // ==== Media acquisition ====
    async function startCamera(initial=false){
      const wantBackOnMobile = isMobile() && initial;
      let constraints = {
        video: wantBackOnMobile ? { facingMode: { ideal:'environment' } } : { facingMode: { ideal:'user' } },
        audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
      };

      if (camSelect.value) constraints.video = { deviceId: { exact: camSelect.value } };

      try{
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        camTrack = s.getVideoTracks()[0] || null;
        micTrack = s.getAudioTracks()[0] || micTrack || null;

        if (!localStream){
          localStream = new MediaStream();
        } else {
          localStream.getTracks().forEach(t=>localStream.removeTrack(t));
        }
        if (camTrack) localStream.addTrack(camTrack);
        if (micTrack) localStream.addTrack(micTrack);

        localV.srcObject = localStream;
        localV.muted = true;

        for (const [, mc] of mediaConns){
          const v = camTrack, a = micTrack;
          if (v) await replaceOutgoing(mc, 'video', v);
          if (a) await replaceOutgoing(mc, 'audio', a);
        }

        subRole.textContent = wantBackOnMobile ? 'Cam√©ra arri√®re' : 'Cam√©ra pr√™te';
      }catch(e){
        toast('Acc√®s cam√©ra/micro refus√© : '+e.message, 'error');
        statusText.textContent = 'Erreur : '+e.message;
      }
    }

    async function switchCamera(){
      let targetDeviceId = null;
      if (camSelect.value) {
        const currentLabel = camSelect.selectedOptions[0]?.textContent?.toLowerCase() || '';
        const want = /(back|rear|environment)/.test(currentLabel) ? 'user' : 'environment';
        targetDeviceId = await getDeviceIdForFacing(want);
        if (!targetDeviceId) targetDeviceId = camSelect.value;
      } else {
        const want = (camTrack && camTrack.getSettings().facingMode === 'environment') ? 'user' : 'environment';
        targetDeviceId = await getDeviceIdForFacing(want);
      }

      async function tryGUM(v){
        try{
          const s = await navigator.mediaDevices.getUserMedia({ video:v, audio:false });
          const vt = s.getVideoTracks()[0];
          if (!vt){ s.getTracks().forEach(t=>t.stop()); return null; }
          return { s, vt };
        }catch{ return null; }
      }

      let attempt = null;
      if (targetDeviceId) attempt = await tryGUM({ deviceId:{ exact: targetDeviceId } });
      if (!attempt) {
        const want = (camTrack?.getSettings()?.facingMode === 'environment') ? 'user' : 'environment';
        attempt = await tryGUM({ facingMode:{ exact: want } }) || await tryGUM({ facingMode:{ ideal: want } }) || await tryGUM({ facingMode: want });
      }
      if (!attempt){ toast('Impossible d‚Äôinverser la cam√©ra (contrainte refus√©e).', 'error'); return; }

      camTrack = attempt.vt;

      const prevAudios = localStream.getAudioTracks();
      localStream = new MediaStream([camTrack, ...prevAudios]);
      localV.srcObject = localStream;

      for (const [, mc] of mediaConns){
        await replaceOutgoing(mc, 'video', camTrack);
      }

      await populateDeviceLists();
      if (targetDeviceId) camSelect.value = targetDeviceId;

      const f = camTrack.getSettings().facingMode || '';
      subRole.textContent = /environment/i.test(f) ? 'Cam√©ra arri√®re' : 'Cam√©ra frontale';

      attempt.s.getTracks().forEach(t=>{ if (t !== camTrack) try{t.stop()}catch{} });
    }

    async function changeMic(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: deviceId }, echoCancellation:true, noiseSuppression:true, autoGainControl:true }, video:false });
        const newMic = s.getAudioTracks()[0];
        if (!newMic){ s.getTracks().forEach(t=>t.stop()); return; }

        const vids = localStream.getVideoTracks();
        if (micTrack){ try{ micTrack.stop(); }catch{} }
        micTrack = newMic;
        localStream = new MediaStream([...vids, micTrack]);
        localV.srcObject = localStream;

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'audio', micTrack);
        }
      }catch(e){ toast('Changement de micro impossible : '+e.message, 'error'); }
    }

    async function changeSpeaker(deviceId){
      for (const [, audio] of remoteAudios){
        if (typeof audio.setSinkId === 'function'){
          try{ await audio.setSinkId(deviceId); }catch(e){ /* ignore */ }
        }
      }
    }

    async function changeCamera(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{ exact: deviceId } }, audio:false });
        const newCam = s.getVideoTracks()[0];
        if (!newCam){ s.getTracks().forEach(t=>t.stop()); return; }
        camTrack = newCam;

        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([camTrack, ...auds]);
        localV.srcObject = localStream;

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', camTrack);
        }
      }catch(e){ toast('Changement de cam√©ra impossible : '+e.message,'error'); }
    }

    // ==== Screen share : remplace uniquement la vid√©o ====
    async function startShare(){
      if (isMobile()){
        toast('Le partage d‚Äô√©cran est disponible uniquement sur ordinateur.', 'warn');
        return;
      }
      try{
        if (isSharing){
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';
          await startCamera(false);
          return;
        }
        if (!navigator.mediaDevices.getDisplayMedia){ toast('Partage non support√© sur ce navigateur','warn'); return; }

        const disp = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false });
        const v = disp.getVideoTracks()[0];
        if (!v){ toast('Aucune piste vid√©o de partage','error'); return; }

        displayVideoTrack = v;
        sharingChip.style.display='inline-flex';
        isSharing=true; btnShareScreen.textContent='‚õî Arr√™ter partage'; mShare.textContent='‚õî';

        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([displayVideoTrack, ...auds]);
        localV.srcObject = localStream;

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', displayVideoTrack);
        }

        displayVideoTrack.addEventListener('ended', async ()=>{
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';
          await startCamera(false);
        });

      }catch(e){ toast('Partage d‚Äô√©cran annul√©','warn'); }
    }

    // ==== Senders replace ====
    async function replaceOutgoing(mediaConn, kind, track){
      const pc = mediaConn?.peerConnection;
      if (!pc) return;
      const sender = pc.getSenders().find(s => s.track && s.track.kind === kind);
      if (sender){
        await sender.replaceTrack(track);
      } else {
        // Fallback soft si le sender n'existe pas (cas timing) : on ajoute la piste
        try { pc.addTrack(track, localStream); } catch {}
      }
    }

    function monitorRemoteMic(stream, peerId){
      const a = stream.getAudioTracks()[0];
      if(!a) return;
      const set = (on) => {
        remoteMicStatus.textContent = on ? 'Micro distant : activ√©' : 'Micro distant : coup√©';
        remoteMicChip.textContent = (on ? 'üé§ ' : 'üîá ') + 'Micro';
      };
      set(a.enabled); a.onmute=()=>set(false); a.onunmute=()=>set(true);
    }

    // ==== Audio & vignettes ====
    function addRemoteAudio(peerId, stream){
      let a = remoteAudios.get(peerId);
      if(!a){
        a = document.createElement('audio');
        a.autoplay = true;
        a.controls = false;
        a.style.display = 'none';
        document.body.appendChild(a);
        remoteAudios.set(peerId, a);
      }
      a.srcObject = stream;
      a.muted = false;
      a.play().catch(()=>{});
      lastSeen.set(peerId, Date.now());
    }

    function buildThumb(peerId, stream, label='Participant'){
      let wrap = document.getElementById('thumb-'+peerId);
      if(!wrap){
        wrap = document.createElement('div');
        wrap.className = 'thumb';
        wrap.id = 'thumb-'+peerId;

        const v = document.createElement('video');
        v.autoplay = true; v.playsInline = true; v.controls = false;
        v.muted = true; // vignette muette
        v.id = 'remote-'+peerId;

        const name = document.createElement('div');
        name.className = 'name'; name.textContent = label;

        wrap.appendChild(v);
        wrap.appendChild(name);
        thumbs.appendChild(wrap);

        remoteVideos.set(peerId, v);

        wrap.addEventListener('click', ()=> setMain(peerId));
      }

      const vid = remoteVideos.get(peerId);
      vid.srcObject = stream;
      vid.play().catch(()=>{});
    }

    function setMain(peerId){
      if(peerId === currentMainPeerId) return;
      const v = remoteVideos.get(peerId);
      if(!v || !v.srcObject) return;

      mainV.srcObject = v.srcObject;
      mainV.muted = true;
      mainV.play().catch(()=>{});

      document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('active'));
      const active = document.getElementById('thumb-'+peerId);
      if(active) active.classList.add('active');

      currentMainPeerId = peerId;
    }

    function removePeerCompletely(peerId){
      // audio
      const a = remoteAudios.get(peerId);
      if(a){ try{ a.srcObject=null; a.remove(); }catch{} remoteAudios.delete(peerId); }

      // vignette vid√©o
      const v = remoteVideos.get(peerId);
      if(v){ try{ v.srcObject=null; }catch{}; remoteVideos.delete(peerId); }
      const wrap = document.getElementById('thumb-'+peerId);
      if(wrap){ wrap.remove(); }

      // connexions
      const mc = mediaConns.get(peerId); if(mc){ try{ mc.close(); }catch{} mediaConns.delete(peerId); }
      const dc = dataConns.get(peerId);  if(dc){ try{ dc.close(); }catch{} dataConns.delete(peerId); }

      if(currentMainPeerId === peerId){
        currentMainPeerId = null;
        const next = [...remoteVideos.keys()][0];
        if(next) setMain(next); else { mainV.srcObject = null; }
      }

      lastSeen.delete(peerId);
      // purge √©ventuelle dans peerIdByUuid (si connu)
      for (const [uuid, pid] of peerIdByUuid){
        if (pid === peerId) peerIdByUuid.delete(uuid);
      }
    }

    // ==== Chat ====
    btnSend.onclick = ()=>{
      const t = msgInput.value.trim(); if(!t) return;
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'chat', text:t}); }
      appendMsg('Moi', t); msgInput.value='';
    };

    // ==== Invite / Join UI ====
    btnInvite.onclick = ()=>{
      if(!peerReady){ toast('Initialisation en cours‚Ä¶', 'warn'); return; }
      const base = `${location.origin}${location.pathname}`;
      const link = `${base}?host=${encodeURIComponent(peer.id)}`; // PATCH: encodeURIComponent
      inviteInput.value = link; inviteField.style.display='flex';
      if(navigator.share && location.protocol === 'https:'){ btnShare.classList.remove('hidden'); }
    };
    btnCopy.onclick = async ()=>{ try{ await navigator.clipboard.writeText(inviteInput.value); toast('Lien copi√©'); }catch{ toast('Copie impossible','warn'); } };
    btnShare.onclick = async ()=>{ try{ await navigator.share({ title:'Rejoindre l‚Äôappel MECASONIC', url: inviteInput.value }); }catch{} };
    btnJoin.onclick = ()=> initCall(hostId);

    // ==== Buttons ====
    btnToggleAudio.onclick = ()=>{
      audioEnabled = !audioEnabled;
      if(micTrack){ micTrack.enabled = audioEnabled; }
      btnToggleAudio.textContent = audioEnabled? 'üîá Couper micro':'üé§ Activer micro';
    };
    btnRotate.onclick = ()=> switchCamera();
    btnShareScreen.onclick = ()=> startShare();
    btnShot.onclick = async ()=>{
      const cvs = await html2canvas(document.querySelector('.video-area'));
      const a=document.createElement('a'); a.href=cvs.toDataURL('image/png'); a.download='screenshot.png'; a.click();
    };
    btnFullscreen.onclick = ()=>{ const el=document.getElementById('video-area'); (el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen||(()=>{})).call(el); };

    // Dock mirrors
    mToggle.onclick = ()=>btnToggleAudio.click();
    mRotate.onclick = ()=>btnRotate.click();
    mShare.onclick  = ()=>btnShareScreen.click();
    mShot.onclick   = ()=>btnShot.click();

    // D√©sactiver UI de partage d‚Äô√©cran sur mobile
    if (isMobile()){ btnShareScreen.style.display='none'; mShare.style.display='none'; }

    // ==== Device selectors bindings ====
    micSelect.onchange = (e)=> changeMic(e.target.value);
    camSelect.onchange = (e)=> changeCamera(e.target.value);
    spkSelect.onchange = (e)=> changeSpeaker(e.target.value);

    // ==== PeerJS events ====
    peer.on('open', async id=>{
      peerReady = true;
      if(isClient){
        btnJoin.style.display='inline-block';
        btnInvite.style.display='none';
        inviteField.style.display='none';
      } else {
        btnInvite.style.display='inline-block';
      }

      await startCamera(true);
      await populateDeviceLists();

      if (isClient && hostId){ initCall(hostId); }
    });

    function broadcastPeersList(){
      const ids = Array.from(mediaConns.keys()).concat([peer.id]).filter(Boolean);
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'peers', ids}); }
    }

    function setupDataConn(dc){
      dataConns.set(dc.peer, dc);
      dc.on('open', ()=>{
        connStatus.textContent='Connect√©'; setConn('ok'); ding.play().catch(()=>{});
        dc.send({type:'hello', id: peer.id, uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien'});
        broadcastPeersList();
      });
      dc.on('close', ()=>{ removePeerCompletely(dc.peer); setConn('warn'); });
      dc.on('error', e=>toast('Erreur data: '+e,'error'));
      dc.on('data', payload=>{
        if (typeof payload === 'string'){ appendMsg(dc.peer, payload); return; }
        if (payload?.type === 'chat'){ appendMsg(dc.peer, payload.text); }
        if (payload?.type === 'peers' && isClient){
          const ids = (payload.ids||[]).filter(pid => pid && pid !== peer.id && !mediaConns.has(pid));
          for (const pid of ids){ callPeer(pid); }
        }
        if (payload?.type === 'hello'){
          if (payload.uuid){
            const existing = peerIdByUuid.get(payload.uuid);
            if (existing && existing !== dc.peer){
              removePeerCompletely(existing);
            }
            peerIdByUuid.set(payload.uuid, dc.peer);
          }
        }
        if (payload?.type === 'ping'){ dc.send({type:'pong', time:payload.time}); }
        if (payload?.type === 'pong'){ updatePing(Date.now()-payload.time); lastSeen.set(dc.peer, Date.now()); }
      });
    }

    peer.on('connection', c => setupDataConn(c));

    function setupMediaConn(mc){
      mediaConns.set(mc.peer, mc);
      mc.on('stream', stream => {
        buildThumb(mc.peer, stream, 'Participant');
        addRemoteAudio(mc.peer, stream);
        monitorRemoteMic(stream, mc.peer);
        lastSeen.set(mc.peer, Date.now());
        if(!currentMainPeerId) setMain(mc.peer);
      });
      mc.on('close', ()=>{ removePeerCompletely(mc.peer); setConn('warn'); });
      mc.on('error', e=> toast('Erreur appel: '+e,'error'));

      mc.peerConnection?.addEventListener('iceconnectionstatechange', ()=>{
        const s = mc.peerConnection.iceConnectionState;
        if(s==='failed' || s==='disconnected'){ setConn('bad'); }
        if(s==='connected'){ setConn('ok'); }
      });
    }

    peer.on('call', async inc=>{
      if(!localStream) await startCamera(false);
      if (inc.metadata?.uuid){
        const existing = peerIdByUuid.get(inc.metadata.uuid);
        if (existing && existing !== inc.peer){
          removePeerCompletely(existing);
        }
        peerIdByUuid.set(inc.metadata.uuid, inc.peer);
      }
      inc.answer(localStream, { metadata:{ uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien' } });
      setupMediaConn(inc);
    });

    peer.on('disconnected', ()=>{ toast('Connexion signalisation perdue. Reconnexion‚Ä¶','warn'); peer.reconnect(); setConn('warn'); });
    peer.on('error', err=>{ console.error(err); toast('Peer error: '+err.type,'error'); setConn('bad'); });

    // ==== Init calls ====
    async function callPeer(remoteId){
      if (!peer.open || !remoteId) return;
      const mc = peer.call(remoteId, localStream, { metadata:{ uuid: SELF_UUID, label: isClient ? 'Client' : 'Technicien' } });
      setupMediaConn(mc);
      const dc = peer.connect(remoteId);
      setupDataConn(dc);
    }

    async function initCall(remoteId){
      if(isCalling){ toast('Connexion d√©j√† en cours‚Ä¶','warn'); return; }
      if(!remoteId || !peer.open){ toast('ID invalide ou Peer non connect√©','error'); return; }
      if(!localStream) await startCamera(false);

      isCalling = true;
      await callPeer(remoteId);

      setTimeout(()=>{ isCalling=false; }, 4000);
      connStatus.textContent='Connexion‚Ä¶';
    }

    // ==== Pings + purge anti-fant√¥mes ====
    setInterval(()=>{
      const now = Date.now();
      for (const [id, dc] of dataConns){
        if (dc.open){ dc.send({type:'ping', time:now}); }
      }
      for (const [peerId, t] of lastSeen){
        if (now - t > 12000){
          removePeerCompletely(peerId);
        }
      }
    }, 3000);

    // ==== PIP local : on peut mettre sa propre vue en grand si voulu ====
    localThumb.addEventListener('click', ()=>{
      mainV.srcObject = localV.srcObject;
      mainV.muted = true;
      mainV.play().catch(()=>{});
      document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('active'));
      currentMainPeerId = null; // aucun remote s√©lectionn√©
    });

    // ==== Speaker select hint ====
    if (!(typeof HTMLMediaElement.prototype.setSinkId === 'function')){
      spkSelect.title = 'Changement de sortie non support√© par ce navigateur';
    }
  });
  </script>
</body>
</html>
