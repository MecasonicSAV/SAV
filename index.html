<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MECASONIC ‚Ä¢ Support vid√©o</title>
  <link rel="preconnect" href="https://unpkg.com" />
  <style>
    :root{
      --bg:#0f1115; --bg-soft:#151823; --panel:#161a25; --text:#e8ecf1; --muted:#9aa3b2;
      --brand:#6aa6ff; --brand-2:#5ef0c1; --danger:#ff6b6b; --warn:#ffb020; --ok:#50d18a;
      --border: rgba(255,255,255,.08); --shadow: 0 8px 30px rgba(0,0,0,.35); --radius:16px;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f5f7fb; --bg-soft:#fff; --panel:#fff; --text:#101318; --muted:#5b6270;
             --border:rgba(16,19,24,.08); --shadow:0 6px 24px rgba(0,0,0,.08); }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
         background:linear-gradient(180deg,var(--bg) 0%,var(--bg-soft) 100%); color:var(--text);}

    /* Topbar */
    .topbar{position:sticky; top:0; z-index:50; backdrop-filter:saturate(1.2) blur(8px);
      background:linear-gradient(90deg,rgba(106,166,255,.08),rgba(94,240,193,.08));
      border-bottom:1px solid var(--border);}
    .topbar-inner{max-width:1200px;margin:0 auto;display:flex;align-items:center;gap:14px;padding:10px 16px;}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700;}
    .badge{font-size:12px;padding:4px 8px;border:1px solid var(--border);border-radius:9999px;background:rgba(255,255,255,.05);color:var(--muted);}
    .status-line{margin-left:auto;display:flex;align-items:center;gap:12px;font-size:14px;}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;box-shadow:0 0 0 3px rgba(255,255,255,.06) inset;}
    .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--danger)} .dot.idle{background:#8a8f9b}

    /* Layout */
    .container{max-width:1200px;margin:24px auto;padding:0 16px 100px;display:grid;grid-template-columns: 1fr 340px;gap:16px;}
    @media (max-width: 980px){ .container{ grid-template-columns:1fr; } }

    /* Panel */
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
    .panel-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border);}
    .panel-title{display:flex;align-items:center;gap:10px;font-weight:600;}
    .role{font-size:12px;color:var(--muted);}

    .video-area{position:relative;aspect-ratio:16/9;background:#0b0e14;display:grid;place-items:center;overflow:hidden;}
    video{width:100%;height:100%;object-fit:cover;background:#000;}
    .grid{display:grid;gap:8px;width:100%;height:100%;}
    .grid.cols-1{grid-template-columns:1fr}
    .grid.cols-2{grid-template-columns:1fr 1fr}
    .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
    .grid.cols-4{grid-template-columns:1fr 1fr; grid-auto-rows:1fr}

    .vid-badges{position:absolute;top:10px;left:10px;display:flex;gap:8px;z-index:3;}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:rgba(0,0,0,.35);}
    .local-thumb{position:absolute;right:12px;bottom:12px;width:220px;max-width:35%;aspect-ratio:16/9;border:1px solid var(--border);border-radius:12px;overflow:hidden;cursor:pointer;box-shadow:var(--shadow);z-index:4;}
    .local-thumb video{width:100%;height:100%;object-fit:cover;}
    @media (max-width:720px){ .local-thumb{ width:140px; } }

    /* Controls */
    .controls{display:flex;flex-wrap:wrap;gap:10px;padding:12px;border-top:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.02),transparent);}
    .btn{appearance:none;border:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.06));color:var(--text);padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:8px;box-shadow:0 2px 0 rgba(0,0,0,.2);}
    .btn:hover{filter:brightness(1.06)} .btn:active{transform:translateY(1px)} .btn.primary{border-color:transparent;background:linear-gradient(90deg,var(--brand),var(--brand-2));color:#0b0e14;}
    .btn.ghost{background:transparent;}
    .field{display:flex;gap:8px;width:100%;}
    input[type="text"], input[readonly], select{flex:1;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.04);color:var(--text);}

    /* Sidebar */
    .side{display:flex;flex-direction:column;gap:12px;}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
    .card-header{padding:10px 12px;border-bottom:1px solid var(--border);font-weight:700;}
    .chat-log{height:280px;overflow:auto;padding:10px 12px;font-size:14px;display:flex;flex-direction:column;gap:6px;}
    .msg{padding:8px 10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:10px;}
    .chat-input{display:flex;gap:8px;padding:10px;} .chat-input input{flex:1;}

    /* Toasts */
    .toasts{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;gap:8px;z-index:100;}
    .toast{padding:10px 14px;border-radius:12px;color:#0b0e14;background:#d1f2e3;box-shadow:var(--shadow);border:1px solid rgba(0,0,0,.06);font-weight:700;}
    .toast.warn{background:#ffeac2} .toast.error{background:#ffd6d6}

    /* Dock mobile */
    .dock{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:rgba(15,17,21,.6);border:1px solid var(--border);border-radius:9999px;padding:8px;display:flex;gap:8px;box-shadow:var(--shadow);backdrop-filter:blur(8px);z-index:60;}
    .dock .btn{padding:10px 12px;}
    @media (min-width:980px){ .dock{display:none;} }

    .hidden{display:none !important;}
  </style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="topbar-inner" aria-live="polite">
      <div class="brand" title="MECASONIC Support Vid√©o">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 12a8 8 0 1 1 16 0" stroke="currentColor" stroke-width="2"/><path d="M12 4v8l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        MECASONIC <span class="badge">Support vid√©o</span>
      </div>
      <div class="status-line">
        <span id="conn-dot" class="dot idle" aria-hidden="true"></span>
        <span id="connection-status">En attente‚Ä¶</span>
        <span aria-hidden="true">‚Ä¢</span><span id="latency">Ping : ‚Ä¶</span>
        <span aria-hidden="true">‚Ä¢</span><span id="remote-mic-status">Micro distant : inconnu</span>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="panel" aria-label="Zone vid√©o">
      <div class="panel-header">
        <div class="panel-title">
          <span id="main-role">Technicien</span>
          <span class="role" id="sub-role">Appel en attente</span>
        </div>
        <div>
          <button class="btn ghost" id="btn-fullscreen" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
      </div>

      <div class="video-area" id="video-area">
        <div class="vid-badges">
          <span class="chip" id="remote-mic-chip">üé§ Micro</span>
          <span class="chip" id="sharing-chip" style="display:none">üñ•Ô∏è Partage d‚Äô√©cran</span>
        </div>

        <!-- Grille multi-vid√©os -->
        <div id="remote-grid" class="grid cols-1"></div>

        <!-- vignette locale -->
        <div class="local-thumb" id="local-thumb" title="Cliquer pour √©changer les vues (PIP)">
          <video id="local-video" autoplay muted playsinline></video>
        </div>
      </div>

      <div class="controls" id="controls">
        <button class="btn primary" id="btn-invite">üîó Inviter</button>
        <button class="btn" id="btn-join" style="display:none">Rejoindre</button>

        <div class="field" id="invite-field" style="display:none">
          <input type="text" id="invite-link" readonly aria-label="Lien d‚Äôinvitation" />
          <button class="btn" id="btn-copy">Copier</button>
          <button class="btn" id="btn-share" title="Partager">Partager</button>
        </div>

        <span style="flex:1"></span>

        <!-- S√©lecteurs p√©riph√©riques -->
        <select id="mic-select" title="Micro"></select>
        <select id="spk-select" title="Haut-parleur (si support√©)"></select>
        <select id="cam-select" title="Cam√©ra"></select>

        <button class="btn" id="btn-toggle-audio">üîá Couper micro</button>
        <button class="btn" id="btn-rotate">‚Ü∫ Inverser cam√©ra</button>
        <button class="btn" id="btn-share-screen">üñ•Ô∏è Partager √©cran</button>
        <button class="btn" id="btn-shot">üì∏ Capture</button>
      </div>
    </section>

    <aside class="side" aria-label="Barre lat√©rale">
      <div class="card">
        <div class="card-header">Chat</div>
        <div class="chat-log" id="messages" aria-live="polite"></div>
        <div class="chat-input">
          <input id="msg-input" placeholder="√âcrire un message‚Ä¶" />
          <button class="btn" id="btn-send">Envoyer</button>
        </div>
      </div>

      <div class="card">
        <div class="card-header">Statut</div>
        <div style="padding:10px 12px; color:var(--muted)" id="status">‚Äî</div>
      </div>
    </aside>
  </main>

  <nav class="dock" aria-label="Raccourcis">
    <button class="btn" id="m-toggle-audio" title="Couper/activer le micro">üéôÔ∏è</button>
    <button class="btn" id="m-rotate" title="Changer de cam√©ra">‚Ü∫</button>
    <button class="btn" id="m-share" title="Partager √©cran">üñ•Ô∏è</button>
    <button class="btn" id="m-shot" title="Capture">üì∏</button>
  </nav>

  <div class="toasts" id="toasts" aria-live="polite" aria-atomic="true"></div>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ==== DOM ====
    const remoteGrid = document.getElementById('remote-grid');
    const localV  = document.getElementById('local-video');
    const localThumb = document.getElementById('local-thumb');

    const btnInvite = document.getElementById('btn-invite');
    const btnJoin   = document.getElementById('btn-join');
    const inviteField = document.getElementById('invite-field');
    const inviteInput = document.getElementById('invite-link');
    const btnCopy   = document.getElementById('btn-copy');
    const btnShare  = document.getElementById('btn-share');

    const btnToggleAudio = document.getElementById('btn-toggle-audio');
    const btnRotate = document.getElementById('btn-rotate');
    const btnShareScreen = document.getElementById('btn-share-screen');
    const btnShot = document.getElementById('btn-shot');
    const btnFullscreen = document.getElementById('btn-fullscreen');

    const micSelect = document.getElementById('mic-select');
    const spkSelect = document.getElementById('spk-select');
    const camSelect = document.getElementById('cam-select');

    const mToggle = document.getElementById('m-toggle-audio');
    const mRotate = document.getElementById('m-rotate');
    const mShare  = document.getElementById('m-share');
    const mShot   = document.getElementById('m-shot');

    const messages = document.getElementById('messages');
    const msgInput = document.getElementById('msg-input');
    const btnSend  = document.getElementById('btn-send');

    const connDot  = document.getElementById('conn-dot');
    const connStatus = document.getElementById('connection-status');
    const latencyEl = document.getElementById('latency');
    const remoteMicStatus = document.getElementById('remote-mic-status');
    const remoteMicChip   = document.getElementById('remote-mic-chip');
    const sharingChip     = document.getElementById('sharing-chip');
    const statusText = document.getElementById('status');

    const mainRole = document.getElementById('main-role');
    const subRole  = document.getElementById('sub-role');

    // ==== Utils / UI ====
    const toasts = document.getElementById('toasts');
    function toast(txt, type=''){ const t=document.createElement('div'); t.className='toast'+(type?(' '+type):''); t.textContent=txt; toasts.appendChild(t); setTimeout(()=>t.remove(), 3200); }
    function setConn(state){ connDot.className = 'dot '+state; }
    function updatePing(ms){ latencyEl.textContent = `Ping : ${ms} ms`; setConn(ms<100?'ok': ms<220?'warn':'bad'); }
    function appendMsg(from, txt){ const el=document.createElement('div'); el.className='msg'; el.textContent = `${from} : ${txt}`; messages.appendChild(el); messages.scrollTop = messages.scrollHeight; }
    const ding = new Audio('https://www.soundjay.com/buttons/sounds/button-3.mp3');
    const isMobile = () => /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    // ==== WebRTC / PeerJS state ====
    const ICE_SERVERS = [
      { urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] },
      // TURN publics pour test ‚Äî remplace par ton propre TURN en production
      { urls: 'turn:openrelay.metered.ca:80',  username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
      { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
    ];
    const peer = new Peer({ debug:2, config:{ iceServers: ICE_SERVERS }, secure: location.protocol==='https:' });

    let peerReady=false, isCalling=false, isSharing=false, displayVideoTrack=null;
    let localStream=null, micTrack=null, camTrack=null;
    let audioEnabled=true;

    // multi-participants
    const mediaConns = new Map();   // peerId -> MediaConnection
    const dataConns  = new Map();   // peerId -> DataConnection
    const remoteVideos = new Map(); // peerId -> <video>

    // R√¥le via URL
    const url = new URL(window.location.href);
    const hostId = url.searchParams.get('host');
    const isClient = Boolean(hostId);

    mainRole.textContent = isClient ? 'Client' : 'Technicien';
    subRole.textContent  = 'En attente de connexion';

    // ==== Devices helpers ====
    async function populateDeviceLists(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const mics = devices.filter(d=>d.kind==='audioinput');
        const spks = devices.filter(d=>d.kind==='audiooutput');
        const cams = devices.filter(d=>d.kind==='videoinput');

        micSelect.innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label||'Micro'}</option>`).join('') || '<option>‚Äî</option>';
        camSelect.innerHTML = cams.map(d=>`<option value="${d.deviceId}">${d.label||'Cam√©ra'}</option>`).join('') || '<option>‚Äî</option>';

        // Speaker selection only where supported
        if (typeof HTMLMediaElement.prototype.setSinkId === 'function' && spks.length){
          spkSelect.innerHTML = spks.map(d=>`<option value="${d.deviceId}">${d.label||'Haut-parleur'}</option>`).join('');
          spkSelect.disabled = false;
        } else {
          spkSelect.innerHTML = '<option>Sortie non support√©e</option>';
          spkSelect.disabled = true;
        }

        // Pr√©-s√©lection arri√®re sur mobile si possible
        if (isMobile()){
          const back = cams.find(c => /back|rear|environment/i.test(c.label));
          if(back){ camSelect.value = back.deviceId; }
        }
      }catch(e){ /* ignore */ }
    }

    async function getDeviceIdForFacing(target){ // 'user'|'environment'
      try{
        const devs = await navigator.mediaDevices.enumerateDevices();
        const cams = devs.filter(d=>d.kind==='videoinput');
        const found = cams.find(c => {
          const L=(c.label||'').toLowerCase();
          return target==='environment' ? /(back|rear|environment)/.test(L) : /(front|user|face)/.test(L);
        });
        return found?.deviceId || null;
      }catch{ return null; }
    }

    // ==== Media acquisition ====
    async function startCamera(initial=false){
      const wantBackOnMobile = isMobile() && initial;
      let constraints = { video: wantBackOnMobile ? { facingMode: { ideal:'environment' } } : { facingMode: { ideal:'user' } }, audio: true };

      // si liste de cams connue, respecter camSelect si choisi
      if (camSelect.value) constraints.video = { deviceId: { exact: camSelect.value } };

      try{
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        camTrack = s.getVideoTracks()[0] || null;
        micTrack = s.getAudioTracks()[0] || micTrack || null;

        if (!localStream){
          localStream = new MediaStream();
        } else {
          // retire anciennes pistes
          localStream.getTracks().forEach(t=>localStream.removeTrack(t));
        }
        if (camTrack) localStream.addTrack(camTrack);
        if (micTrack) localStream.addTrack(micTrack);

        localV.srcObject = localStream;
        localV.muted = true;

        // push to RTCRtpSender if connected
        for (const [, mc] of mediaConns){
          const v = camTrack, a = micTrack;
          if (v) await replaceOutgoing(mc, 'video', v);
          if (a) await replaceOutgoing(mc, 'audio', a);
        }

        subRole.textContent = wantBackOnMobile ? 'Cam√©ra arri√®re' : 'Cam√©ra pr√™te';
      }catch(e){
        toast('Acc√®s cam√©ra/micro refus√© : '+e.message, 'error');
        statusText.textContent = 'Erreur : '+e.message;
      }
    }

    async function switchCamera(){
      // essaye par deviceId (select) prioritaire
      let targetDeviceId = null;
      if (camSelect.value) {
        // bascule entre arri√®re/avant si possible
        const currentLabel = camSelect.selectedOptions[0]?.textContent?.toLowerCase() || '';
        const want = /(back|rear|environment)/.test(currentLabel) ? 'user' : 'environment';
        targetDeviceId = await getDeviceIdForFacing(want);
        if (!targetDeviceId) targetDeviceId = camSelect.value; // fallback same
      } else {
        const want = (camTrack && camTrack.getSettings().facingMode === 'environment') ? 'user' : 'environment';
        targetDeviceId = await getDeviceIdForFacing(want);
      }

      // build constraints cascade
      async function tryGUM(v){
        try{
          const s = await navigator.mediaDevices.getUserMedia({ video:v, audio:false });
          const vt = s.getVideoTracks()[0];
          if (!vt){ s.getTracks().forEach(t=>t.stop()); return null; }
          return { s, vt };
        }catch{ return null; }
      }

      let attempt = null;
      if (targetDeviceId) attempt = await tryGUM({ deviceId:{ exact: targetDeviceId } });
      if (!attempt) {
        const want = (camTrack?.getSettings()?.facingMode === 'environment') ? 'user' : 'environment';
        attempt = await tryGUM({ facingMode:{ exact: want } }) || await tryGUM({ facingMode:{ ideal: want } }) || await tryGUM({ facingMode: want });
      }
      if (!attempt){ toast('Impossible d‚Äôinverser la cam√©ra (contrainte refus√©e).', 'error'); return; }

      // replace video track only (keep mic)
      camTrack = attempt.vt;

      // preview local
      const prevAudios = localStream.getAudioTracks();
      localStream = new MediaStream([camTrack, ...prevAudios]);
      localV.srcObject = localStream;

      // senders
      for (const [, mc] of mediaConns){
        await replaceOutgoing(mc, 'video', camTrack);
      }

      // update selector
      await populateDeviceLists();
      if (targetDeviceId) camSelect.value = targetDeviceId;

      const f = camTrack.getSettings().facingMode || '';
      subRole.textContent = /environment/i.test(f) ? 'Cam√©ra arri√®re' : 'Cam√©ra frontale';

      // stop temp tracks we didn‚Äôt keep
      attempt.s.getTracks().forEach(t=>{ if (t !== camTrack) try{t.stop()}catch{} });
    }

    async function changeMic(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: deviceId } }, video:false });
        const newMic = s.getAudioTracks()[0];
        if (!newMic){ s.getTracks().forEach(t=>t.stop()); return; }

        // replace in local stream
        const vids = localStream.getVideoTracks();
        if (micTrack){ try{ micTrack.stop(); }catch{} }
        micTrack = newMic;
        localStream = new MediaStream([...vids, micTrack]);
        localV.srcObject = localStream;

        // replace in all senders
        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'audio', micTrack);
        }
      }catch(e){ toast('Changement de micro impossible : '+e.message, 'error'); }
    }

    async function changeSpeaker(deviceId){
      // apply to all remote videos that support setSinkId
      for (const [, video] of remoteVideos){
        if (typeof video.sinkId === 'string' || typeof video.setSinkId === 'function'){
          try{ await video.setSinkId(deviceId); }catch(e){ /* ignore */ }
        }
      }
    }

    async function changeCamera(deviceId){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{ exact: deviceId } }, audio:false });
        const newCam = s.getVideoTracks()[0];
        if (!newCam){ s.getTracks().forEach(t=>t.stop()); return; }
        camTrack = newCam;

        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([camTrack, ...auds]);
        localV.srcObject = localStream;

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', camTrack);
        }
      }catch(e){ toast('Changement de cam√©ra impossible : '+e.message,'error'); }
    }

    // ==== Screen share (PC only) : replace VIDEO track only ====
    async function startShare(){
      if (isMobile()){
        toast('Le partage d‚Äô√©cran est disponible uniquement sur ordinateur.', 'warn');
        return;
      }
      try{
        if (isSharing){
          // stop share -> back to camera
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';

          // restore camera video
          await startCamera(false);
          return;
        }
        if (!navigator.mediaDevices.getDisplayMedia){ toast('Partage non support√© sur ce navigateur','warn'); return; }

        const disp = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false });
        const v = disp.getVideoTracks()[0];
        if (!v){ toast('Aucune piste vid√©o de partage','error'); return; }

        // Replace only VIDEO sender (keep micTrack as is)
        displayVideoTrack = v;
        sharingChip.style.display='inline-flex';
        isSharing=true; btnShareScreen.textContent='‚õî Arr√™ter partage'; mShare.textContent='‚õî';

        // Preview local = vid√©o partage + audio local (non n√©cessaire en preview)
        const auds = localStream.getAudioTracks();
        localStream = new MediaStream([displayVideoTrack, ...auds]);
        localV.srcObject = localStream;

        for (const [, mc] of mediaConns){
          await replaceOutgoing(mc, 'video', displayVideoTrack);
        }

        // when user stops sharing via browser UI
        displayVideoTrack.addEventListener('ended', async ()=>{
          isSharing=false; sharingChip.style.display='none';
          btnShareScreen.textContent='üñ•Ô∏è Partager √©cran'; mShare.textContent='üñ•Ô∏è';
          await startCamera(false);
        });

      }catch(e){ toast('Partage d‚Äô√©cran annul√©','warn'); }
    }

    // ==== Senders replace ====
    async function replaceOutgoing(mediaConn, kind, track){
      const pc = mediaConn?.peerConnection;
      if (!pc) return;
      const sender = pc.getSenders().find(s => s.track && s.track.kind === kind);
      if (sender){ await sender.replaceTrack(track); }
    }

    function monitorRemoteMic(stream, videoEl){
      const a = stream.getAudioTracks()[0];
      if(!a) return;
      const set = (on) => {
        remoteMicStatus.textContent = on ? 'Micro distant : activ√©' : 'Micro distant : coup√©';
        remoteMicChip.textContent = (on ? 'üé§ ' : 'üîá ') + 'Micro';
        videoEl.dataset.mic = on ? 'on' : 'off';
      };
      set(a.enabled); a.onmute=()=>set(false); a.onunmute=()=>set(true);
    }

    // ==== Remote video management (multi-participants) ====
    function ensureGridCols(){
      const n = remoteVideos.size || 1;
      remoteGrid.className = 'grid ' + (n<=1?'cols-1': n===2?'cols-2': n===3?'cols-3':'cols-4');
    }

    function addRemoteVideo(peerId, stream){
      let v = remoteVideos.get(peerId);
      if (!v){
        v = document.createElement('video');
        v.autoplay = true; v.playsInline = true; v.controls = false;
        v.id = 'remote-'+peerId;
        remoteGrid.appendChild(v);
        remoteVideos.set(peerId, v);
        ensureGridCols();
      }
      v.srcObject = stream;
      v.muted = false;

      // mobile autoplay unlock helper
      if (isMobile()){
        const b=document.createElement('button'); b.textContent='üîä Activer le son';
        b.style.position='fixed'; b.style.right='16px'; b.style.bottom='16px'; b.style.zIndex=80;
        b.onclick=()=>{ v.muted=false; v.play().catch(()=>{}); b.remove(); };
        document.body.appendChild(b);
      }
      monitorRemoteMic(stream, v);
      v.play().catch(()=>{});
    }

    function removeRemoteVideo(peerId){
      const v = remoteVideos.get(peerId);
      if (v){ try{ v.srcObject=null; v.remove(); }catch{} remoteVideos.delete(peerId); ensureGridCols(); }
    }

    // ==== Chat (broadcast to all dataConns) ====
    btnSend.onclick = ()=>{
      const t = msgInput.value.trim(); if(!t) return;
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'chat', text:t}); }
      appendMsg('Moi', t); msgInput.value='';
    };

    // ==== Invite / Join UI ====
    btnInvite.onclick = ()=>{
      if(!peerReady){ toast('Initialisation en cours‚Ä¶', 'warn'); return; }
      const base = location.origin + location.pathname;
      const link = `${base}?host=${peer.id}`;
      inviteInput.value = link; inviteField.style.display='flex';
      if(navigator.share && location.protocol === 'https:'){ btnShare.classList.remove('hidden'); }
    };
    btnCopy.onclick = async ()=>{ try{ await navigator.clipboard.writeText(inviteInput.value); toast('Lien copi√©'); }catch{ toast('Copie impossible','warn'); } };
    btnShare.onclick = async ()=>{ try{ await navigator.share({ title:'Rejoindre l‚Äôappel MECASONIC', url: inviteInput.value }); }catch{} };
    btnJoin.onclick = ()=> initCall(hostId);

    // ==== Buttons ====
    btnToggleAudio.onclick = ()=>{ audioEnabled = !audioEnabled; if(micTrack){ micTrack.enabled = audioEnabled; } btnToggleAudio.textContent = audioEnabled? 'üîá Couper micro':'üé§ Activer micro'; };
    btnRotate.onclick = ()=> switchCamera();
    btnShareScreen.onclick = ()=> startShare();
    btnShot.onclick = async ()=>{ const cvs = await html2canvas(document.querySelector('.video-area')); const a=document.createElement('a'); a.href=cvs.toDataURL('image/png'); a.download='screenshot.png'; a.click(); };
    btnFullscreen.onclick = ()=>{ const el=document.getElementById('video-area'); (el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen||(()=>{})).call(el); };

    // Dock mirrors
    mToggle.onclick = ()=>btnToggleAudio.click();
    mRotate.onclick = ()=>btnRotate.click();
    mShare.onclick  = ()=>btnShareScreen.click();
    mShot.onclick   = ()=>btnShot.click();

    // D√©sactiver UI de partage d‚Äô√©cran sur mobile
    if (isMobile()){ btnShareScreen.style.display='none'; mShare.style.display='none'; }

    // ==== Device selectors bindings ====
    micSelect.onchange = (e)=> changeMic(e.target.value);
    camSelect.onchange = (e)=> changeCamera(e.target.value);
    spkSelect.onchange = (e)=> changeSpeaker(e.target.value);

    // ==== PeerJS events ====
    peer.on('open', async id=>{
      peerReady = true;
      if(isClient){
        btnJoin.style.display='inline-block';
        btnInvite.style.display='none';
        inviteField.style.display='none';
      } else {
        btnInvite.style.display='inline-block';
      }

      // start camera with defaults (rear on mobile)
      await startCamera(true);
      await populateDeviceLists();

      if (isClient && hostId){ initCall(hostId); }
    });

    // Host / Client data channel logic for mesh
    function broadcastPeersList(){
      const ids = Array.from(mediaConns.keys()).concat([peer.id]).filter(Boolean);
      for (const [, dc] of dataConns){ if (dc.open) dc.send({type:'peers', ids}); }
    }

    function setupDataConn(dc){
      dataConns.set(dc.peer, dc);
      dc.on('open', ()=>{
        connStatus.textContent='Connect√©'; setConn('ok'); ding.play().catch(()=>{});
        // send my id & ask for list
        dc.send({type:'hello', id: peer.id});
        // host broadcasts full list to everyone
        broadcastPeersList();
      });
      dc.on('close', ()=>{ dataConns.delete(dc.peer); setConn('warn'); removeRemoteVideo(dc.peer); });
      dc.on('error', e=>toast('Erreur data: '+e,'error'));
      dc.on('data', async payload=>{
        if (typeof payload === 'string'){
          appendMsg(dc.peer, payload);
          return;
        }
        if (payload?.type === 'chat'){ appendMsg(dc.peer, payload.text); }
        if (payload?.type === 'peers' && isClient){
          // call each peer in the list (except me & except already connected)
          const ids = (payload.ids||[]).filter(pid => pid && pid !== peer.id && !mediaConns.has(pid));
          for (const pid of ids){ callPeer(pid); }
        }
        if (payload?.type === 'hello' && !isClient){
          // host sends the full list back to newcomer
          broadcastPeersList();
        }
        if (payload?.type === 'ping'){ dc.send({type:'pong', time:payload.time}); }
        if (payload?.type === 'pong'){ updatePing(Date.now()-payload.time); }
      });
    }

    peer.on('connection', c => setupDataConn(c));

    function setupMediaConn(mc){
      mediaConns.set(mc.peer, mc);
      mc.on('stream', stream => addRemoteVideo(mc.peer, stream));
      mc.on('close', ()=>{ mediaConns.delete(mc.peer); removeRemoteVideo(mc.peer); setConn('warn'); });
      mc.on('error', e=> toast('Erreur appel: '+e,'error'));

      // ICE state (diagnostic)
      mc.peerConnection?.addEventListener('iceconnectionstatechange', ()=>{
        const s = mc.peerConnection.iceConnectionState;
        if(s==='failed' || s==='disconnected'){ setConn('bad'); }
        if(s==='connected'){ setConn('ok'); }
      });
    }

    peer.on('call', async inc=>{
      if(!localStream) await startCamera(false);
      inc.answer(localStream, { metadata:{ audio:true, video:true } });
      setupMediaConn(inc);
    });

    peer.on('disconnected', ()=>{ toast('Connexion signalisation perdue. Reconnexion‚Ä¶','warn'); peer.reconnect(); setConn('warn'); });
    peer.on('error', err=>{ console.error(err); toast('Peer error: '+err.type,'error'); setConn('bad'); });

    // ==== Init calls ====
    async function callPeer(remoteId){
      if (!peer.open || !remoteId) return;
      const mc = peer.call(remoteId, localStream);
      setupMediaConn(mc);
      const dc = peer.connect(remoteId);
      setupDataConn(dc);
    }

    async function initCall(remoteId){
      if(isCalling){ toast('Connexion d√©j√† en cours‚Ä¶','warn'); return; }
      if(!remoteId || !peer.open){ toast('ID invalide ou Peer non connect√©','error'); return; }
      if(!localStream) await startCamera(false);

      isCalling = true;

      // call host
      await callPeer(remoteId);

      // guard timeout (soft)
      setTimeout(()=>{ isCalling=false; }, 4000);
      connStatus.textContent='Connexion‚Ä¶';
    }

    // ==== Pings ====
    setInterval(()=>{ for (const [, dc] of dataConns){ if(dc.open) dc.send({type:'ping', time:Date.now()}); } }, 3000);

    // ==== PIP swap (local <-> first remote) ====
    localThumb.addEventListener('click', ()=>{
      // swap avec le premier remote si pr√©sent
      const firstRemote = remoteGrid.querySelector('video');
      if (!firstRemote) return;
      const a = firstRemote.srcObject, b = localV.srcObject;
      firstRemote.srcObject = b; localV.srcObject = a;
    });

    // ==== Speaker select initial hint ====
    if (!(typeof HTMLMediaElement.prototype.setSinkId === 'function')){
      spkSelect.title = 'Changement de sortie non support√© par ce navigateur';
    }
  });
  </script>
</body>
</html>
